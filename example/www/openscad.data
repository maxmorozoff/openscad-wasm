/*
 * Multiplication along certain curves
 *
 * Copyright by Elmo Mäntynen, 2012.
 * Licenced under LGPL2 or later
 */

include <units.scad>

use <utilities.scad>

// Copy everything $no of times around an $axis, spread over $angle
// If $strict==true or $angle==360, then spacing will leave an empty at $angle,
//  otherwise, $no will be distributed so first is at 0deg, last copy at $angle degrees
// NOTE: $axis works (rotates around that axis), but pass parameter as lower case string
//  eg: "x", "y", or "z". Alternatively, use units.scad vector definitions: X, Y, Z
module spin(no, angle=360, axis=Z, strict=false){
    divisor = (strict || angle==360) ? no : no-1;
    for (i = [0:no-1])
        rotate(normalized_axis(axis)*angle*i/divisor)
            children();
}

// Make a copy of children by rotating around $axis by 180 degrees
module duplicate(axis=Z) spin(no=2, axis=axis) children();

// Make $no copies along the $axis, separated by $separation
module linear_multiply(no, separation, axis=Z)
    for (i = [0:no-1])
        translate(i*separation*normalized_axis(axis)) children();
/*
 *  OpenSCAD Shapes Library (www.openscad.org)
 *  Copyright (C) 2009  Catarina Mota
 *  Copyright (C) 2010  Elmo Mäntynen
 *
 *  License: LGPL 2.1 or later
*/

include <units.scad>

/*
2D Shapes
ngon(sides, radius, center=false);

3D Shapes
box(width, height, depth);
roundedBox(width, height, depth, radius);
cone(height, radius);
ellipticalCylinder(width, height, depth);
ellipsoid(width, height);
tube(height, radius, wall, center = false);
tube2(height, ID, OD, center = false);
ovalTube(width, height, depth, wall, center = false);
hexagon(height, depth);
octagon(height, depth);
dodecagon(height, depth);
hexagram(height, depth);

rightTriangle(adjacent, opposite, depth);
equiTriangle(side, depth);
12ptStar(height, depth);
*/

//----------------------

echo_deprecated_shapes_library();

module echo_deprecated_shapes_library() {
     echo("<font color='red'>
           DEPRECATED: 'shapes' library is now deprecated
           please use 'regular_shapes' instead</font>");
}

// size is a vector [w, h, d]
module box(width, height, depth) {
  echo_deprecated_shapes_library();
  cube([width, height, depth], true);
}

// size is a vector [w, h, d]
module roundedBox(width, height, depth, radius) {
  echo_deprecated_shapes_library();
  size=[width, height, depth];
  cube(size - [2*radius,0,0], true);
  cube(size - [0,2*radius,0], true);
  for (x = [radius-size[0]/2, -radius+size[0]/2],
       y = [radius-size[1]/2, -radius+size[1]/2]) {
    translate([x,y,0]) cylinder(r=radius, h=size[2], center=true);
  }
}

module cone(height, radius, center = false) {
  echo_deprecated_shapes_library();
  cylinder(height, radius, 0, center);
}

module ellipticalCylinder(w,h, height, center = false) {
  echo_deprecated_shapes_library();
  scale([1, h/w, 1]) cylinder(h=height, r=w, center=center);
}

module ellipsoid(w, h, center = false) {
  echo_deprecated_shapes_library();
  scale([1, h/w, 1]) sphere(r=w/2, center=center);
}

// wall is wall thickness
module tube(height, radius, wall, center = false) {
  echo_deprecated_shapes_library();
  linear_extrude (height = height, center = center) {
    difference() {
      circle(r = radius);
      circle(r = radius - wall);
    }
  }
  difference() {
    cylinder(h=height, r=radius, center=center);
    translate([0,0,-epsilon])
      cylinder(h=height+2*epsilon, r=radius-wall, center=center);
  }
}

module tube2(height, ID, OD, center = false) {
  tube(height = height, center = center, radius = OD / 2, wall = (OD - ID)/2);
}

// wall is wall thickness
module ovalTube(height, rx, ry, wall, center = false) {
  echo_deprecated_shapes_library();
  difference() {
    scale([1, ry/rx, 1]) cylinder(h=height, r=rx, center=center);
    scale([(rx-wall)/rx, (ry-wall)/rx, 1]) cylinder(h=height, r=rx, center=center);
  }
}

// size is the XY plane size, height in Z
module hexagon(size, height) {
  echo_deprecated_shapes_library();
  boxWidth = size/1.75;
  for (r = [-60, 0, 60])
    rotate([0,0,r])
      cube([boxWidth, size, height], true);
}

// size is the XY plane size, height in Z
module octagon(size, height) {
  echo_deprecated_shapes_library();
  intersection() {
    cube([size, size, height], true);
    rotate([0,0,45])
      cube([size, size, height], true);
  }
}

// size is the XY plane size, height in Z
module dodecagon(size, height) {
  echo_deprecated_shapes_library();
  intersection() {
    hexagon(size, height);
    rotate([0,0,90]) hexagon(size, height);
  }
}

// size is the XY plane size, height in Z
module hexagram(size, height) {
  echo_deprecated_shapes_library();
  boxWidth=size/1.75;
  for (v = [[0,1],[0,-1],[1,-1]]) {
    intersection() {
      rotate([0,0,60*v[0]]) cube([size, boxWidth, height], true);
      rotate([0,0,60*v[1]]) cube([size, boxWidth, height], true);
    }
  }
}

module rightTriangle(adjacent, opposite, height) {
  echo_deprecated_shapes_library();
  difference() {
    translate([-adjacent/2,opposite/2,0])
      cube([adjacent, opposite, height], true);
    translate([-adjacent,0,0]) {
      rotate([0,0,atan(opposite/adjacent)])
        dislocateBox(adjacent*2, opposite, height+2);
    }
  }
}

module equiTriangle(side, height) {
  echo_deprecated_shapes_library();
  difference() {
    translate([-side/2,side/2,0]) cube([side, side, height], true);
    rotate([0,0,30]) dislocateBox(side*2, side, height);
    translate([-side,0,0]) {
      rotate([0,0,60]) dislocateBox(side*2, side, height);
    }
  }
}

module 12ptStar(size, height) {
  echo_deprecated_shapes_library();
  starNum = 3;
  starAngle = 90/starNum;
  for (s = [1:starNum]) {
    rotate([0, 0, s*starAngle]) cube([size, size, height], true);
  }
}

//-----------------------
//MOVES THE ROTATION AXIS OF A BOX FROM ITS CENTER TO THE BOTTOM LEFT CORNER
module dislocateBox(w, h, d) {
  translate([0,0,-d/2]) cube([w,h,d]);
}
/*
 *  OpenSCAD Metric Fastners Library (www.openscad.org)
 *  Copyright (C) 2010-2011  Giles Bathgate
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License,
 *  LGPL version 2.1, or (at your option) any later version of the GPL.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
*/

$fn=50;
apply_chamfer=true;

module cap_bolt(dia,len)
{
	e=1.5*dia;
	h1=1.25*dia;
	cylinder(r=dia/2,h=len);
	translate([0,0,-h1]) cylinder(r=e/2,h=h1);
}

module csk_bolt(dia,len)
{
	h1=0.6*dia;
	h2=len-h1;
	cylinder(r=dia/2,h=h2);
	cylinder(r1=dia,r2=dia/2,h=h1);
}

module washer(dia)
{
	t=0.1*dia;
	difference()
	{
		cylinder(r=dia,h=t);
		translate([0,0,-t/2])cylinder(r=dia/2,h=t*2);
	}
}

module flat_nut(dia)
{
	m=0.8*dia;
	e=1.8*dia;
	c=0.2*dia;
	difference()
	{
		cylinder(r=e/2,h=m,$fn=6);
		translate([0,0,-m/2])cylinder(r=dia/2,h=m*2);
		if(apply_chamfer)
		    translate([0,0,c])cylinder_chamfer(e/2,c);
	}
}

module bolt(dia,len)
{
	e=1.8*dia;
	k=0.7*dia;
	c=0.2*dia;
	difference()
	{
		cylinder(r=e/2,h=k,$fn=6);
		if(apply_chamfer)
		    translate([0,0,c])cylinder_chamfer(e/2,c);
	}

	cylinder(r=dia/2,h=len);

}

module cylinder_chamfer(r1,r2)
{
	t=r1-r2;
	p=r2*2;
	rotate_extrude()
	difference()
	{
		translate([t,-p])square([p,p]);
		translate([t,0])circle(r2);
	}
}

module chamfer(len,r)
{
	p=r*2;
	linear_extrude(height=len)
	difference()
	{
		square([p,p]);
		circle(r);
	}
}

union()
{
//csk_bolt(3,14);
//washer(3);
//flat_nut(3);
//bolt(4,14);
//cylinder_chamfer(8,1);
//chamfer(10,2);
}
from openscad_testing import *
// Parametric screw-like things (ball screws, augers)
// License: GNU LGPL 2.1 or later.
// © 2010 by Elmo Mäntynen

include <curves.scad>

/* common screw parameter
length
pitch = length/rotations: the distance between the turns of the thread
outside_diameter
inner_diameter: thickness of the shaft
*/

//Uncomment to see examples
//test_auger();
//test_ball_groove();
//test_ball_groove2();
//test_ball_screw();

module helix(pitch, length, slices=500){
    rotations = length/pitch;
    linear_extrude(height=length, center=false, convexity=10, twist=360*rotations, slices=slices, $fn=100)
        children();
}

module auger(pitch, length, outside_radius, inner_radius, taper_ratio = 0.25) {
    union(){
        helix(pitch, length)
        polygon(points=[[0,inner_radius],[outside_radius,(inner_radius * taper_ratio)],[outside_radius,(inner_radius * -1 * taper_ratio)],[0,(-1 * inner_radius)]], paths=[[0,1,2,3]]);
        cylinder(h=length, r=inner_radius);
    }
}

module test_auger(){translate([50, 0, 0]) auger(40, 80, 25, 5);}


module ball_groove(pitch, length, diameter, ball_radius=10) {
    helix(pitch, length, slices=100)
        translate([diameter, 0, 0])
        circle(r = ball_radius);
}

module test_ball_groove(){ translate([0, 300, 0]) ball_groove(100, 300, 10);}

module ball_groove2(pitch, length, diameter, ball_radius, slices=200){
    rotations = length/pitch;
    radius=diameter/2;
    offset = length/slices;
    union(){
        for (i = [0:slices]) {
            assign (z = i*offset){
                translate(helix_curve(pitch, radius, z)) sphere(ball_radius, $fa=5, $fs=1);
            }
        }
    }
}

module test_ball_groove2(){translate([0, 0, 0]) ball_groove2(100, 300, 100, 10);}

module ball_screw(pitch, length, bearing_radius=2) {

}

module test_ball_screw(){}
/*********************************
* OpenSCAD GridBeam Library      *
* (c) Timothy Schmidt 2013       *
* http://www.github.com/gridbeam *
* License: LGPL 2.1 or later     *
*********************************/

/* Todo:
 - implement "dxf" mode
 - implement hole cutout pattern - interference based on hole size, compatible with two sizes above and below the currently set size.
*/

// zBeam(segments) - create a vertical gridbeam strut 'segments' long
// xBeam(segments) - create a horizontal gridbeam strut along the X axis
// yBeam(segments) - create a horizontal gridbeam strut along the Y axis
// zBolt(segments) - create a bolt 'segments' in length
// xBolt(segments)
// yBolt(segments)
// topShelf(width, depth, corners) - create a shelf suitable for use in gridbeam structures width and depth in 'segments', corners == 1 notches corners
// bottomShelf(width, depth, corners) - like topShelf, but aligns shelf to underside of beams
// backBoard(width, height, corners) - create a backing board suitable for use in gridbeam structures width and height in 'segments', corners == 1 notches corners
// frontBoard(width, height, corners) - like backBoard, but aligns board to front side of beams
// translateBeam([x, y, z]) - translate gridbeam struts or shelves in X, Y, or Z axes in units 'segments'

// To render the DXF file from the command line:
// openscad -x connector.dxf -D'mode="dxf"' connector.scad
mode = "model";
//mode = "dxf";

include <units.scad>

beam_width = inch * 1.5;
beam_hole_diameter = inch * 5/16;
beam_hole_radius = beam_hole_diameter / 2;
beam_is_hollow = 1;
beam_wall_thickness = inch * 1/8;
beam_shelf_thickness = inch * 1/4;

module zBeam(segments) {
if (mode == "model") {
	difference() {
		cube([beam_width, beam_width, beam_width * segments]);
		for(i = [0 : segments - 1]) {
			translate([beam_width / 2, beam_width + 1, beam_width * i + beam_width / 2])
			rotate([90,0,0])
			cylinder(r=beam_hole_radius, h=beam_width + 2);

			translate([-1, beam_width / 2, beam_width * i + beam_width / 2])
			rotate([0,90,0])
			cylinder(r=beam_hole_radius, h=beam_width + 2);
		}
	if (beam_is_hollow == 1) {
		translate([beam_wall_thickness, beam_wall_thickness, -1])
		cube([beam_width - beam_wall_thickness * 2, beam_width - beam_wall_thickness * 2, beam_width * segments + 2]);
	}
}
}

if (mode == "dxf") {

}
}

module xBeam(segments) {
if (mode == "model") {
	translate([0,0,beam_width])
	rotate([0,90,0])
	zBeam(segments);
}

if (mode == "dxf") {

}
}

module yBeam(segments) {
if (mode == "model") {
	translate([0,0,beam_width])
	rotate([-90,0,0])
	zBeam(segments);
}

if (mode == "dxf") {

}
}

module zBolt(segments) {
if (mode == "model") {

}

if (mode == "dxf") {

}
}

module xBolt(segments) {
if (mode == "model") {
}

if (mode == "dxf") {

}
}

module yBolt(segments) {
if (mode == "model") {
}

if (mode == "dxf") {

}
}

module translateBeam(v) translate(v * beam_width) children([0 : $children - 1]);

module topShelf(width, depth, corners) {
if (mode == "model") {
	difference() {
		cube([width * beam_width, depth * beam_width, beam_shelf_thickness]);

		if (corners == 1) {
		translate([-1,  -1,  -1])
		cube([beam_width + 2, beam_width + 2, beam_shelf_thickness + 2]);
		translate([-1, (depth - 1) * beam_width, -1])
		cube([beam_width + 2, beam_width + 2, beam_shelf_thickness + 2]);
		translate([(width - 1) * beam_width, -1, -1])
		cube([beam_width + 2, beam_width + 2, beam_shelf_thickness + 2]);
		translate([(width - 1) * beam_width, (depth - 1) * beam_width, -1])
		cube([beam_width + 2, beam_width + 2, beam_shelf_thickness + 2]);
		}
	}
}

if (mode == "dxf") {

}
}

module bottomShelf(width, depth, corners) {
if (mode == "model") {
	translate([0,0,-beam_shelf_thickness])
	topShelf(width, depth, corners);
}

if (mode == "dxf") {

}
}

module  backBoard(width, height, corners) {
if (mode == "model") {
	translate([beam_width, 0, 0])
	difference() {
		cube([beam_shelf_thickness, width * beam_width, height * beam_width]);

		if (corners == 1) {
		translate([-1,  -1,  -1])
		cube([beam_shelf_thickness + 2, beam_width + 2, beam_width + 2]);
		translate([-1, -1, (height - 1) * beam_width])
		cube([beam_shelf_thickness + 2, beam_width + 2, beam_width + 2]);
		translate([-1, (width - 1) * beam_width, -1])
		cube([beam_shelf_thickness + 2, beam_width + 2, beam_width + 2]);
		translate([-1, (width - 1) * beam_width, (height - 1) * beam_width])
		cube([beam_shelf_thickness + 2, beam_width + 2, beam_width + 2]);
		}
	}
}

if (mode == "dxf") {

}
}

module frontBoard(width, height, corners) {
if (mode == "model") {
	translate([-beam_width - beam_shelf_thickness, 0, 0])
	backBoard(width, height, corners);
}

if (mode == "dxf") {

}
}
// Library: boxes.scad
// Version: 1.0
// Author: Marius Kintel
// Copyright: 2010
// License: 2-clause BSD License (http://opensource.org/licenses/BSD-2-Clause)

// 
// roundedCube([x, y, z], r, sidesonly=true/false, center=true/false);
// roundedCube(x, r, sidesonly=true/false, center=true/false);

// EXAMPLE USAGE:
// roundedCube([20, 30, 40], 5, true, true);

// Only for backwards compatibility with existing scripts, (always centered, radius instead of consistent "r" naming.
module roundedBox(size, radius, sidesonly)
{
  echo("WARNING: roundedBox(size, radius, sidesonly) is deprecated, use roundedCube(size, r, sidesonly, center)");
  roundedCube(size, radius, sidesonly, true);
}

// New implementation
module roundedCube(size, r, sidesonly, center) {
  s = is_list(size) ? size : [size,size,size];
  translate(center ? -s/2 : [0,0,0]) {
    if (sidesonly) {
      hull() {
        translate([     r,     r]) cylinder(r=r, h=s[2]);
        translate([     r,s[1]-r]) cylinder(r=r, h=s[2]);
        translate([s[0]-r,     r]) cylinder(r=r, h=s[2]);
        translate([s[0]-r,s[1]-r]) cylinder(r=r, h=s[2]);
      }
    }
    else {
      hull() {
        translate([     r,     r,     r]) sphere(r=r);
        translate([     r,     r,s[2]-r]) sphere(r=r);
        translate([     r,s[1]-r,     r]) sphere(r=r);
        translate([     r,s[1]-r,s[2]-r]) sphere(r=r);
        translate([s[0]-r,     r,     r]) sphere(r=r);
        translate([s[0]-r,     r,s[2]-r]) sphere(r=r);
        translate([s[0]-r,s[1]-r,     r]) sphere(r=r);
        translate([s[0]-r,s[1]-r,s[2]-r]) sphere(r=r);
      }
    }
  }
}
  /*
 *  OpenSCAD Layout Library (www.openscad.org)
 *  Copyright (C) 2012 Peter Uithoven
 *
 *  License: LGPL 2.1 or later
*/

//list(iHeight);
//grid(iWidth,iHeight,inYDir = true,limit=3)

// Examples:
/*list(15)
{
	square([25,10]);
	square([25,10]);
    square([25,10]);
	square([25,10]);
    square([25,10]);
}*/
/*grid(30,15,false,2)
{
	square([25,10]);
	square([25,10]);
    square([25,10]);
	square([25,10]);
    square([25,10]);
}*/

//----------------------

module list(iHeight)
{
	for (i = [0 : $children-1]) 
		translate([0,i*iHeight]) children(i);
}
module grid(iWidth,iHeight,inYDir = true,limit=3)
{
	for (i = [0 : $children-1]) 
	{
		translate([(inYDir)? (iWidth)*(i%limit) : (iWidth)*floor(i/limit),
					(inYDir)? (iHeight)*floor(i/limit) : (iHeight)*(i%limit)])
					children(i);
	}
}import py, re, os, signal, time, subprocess, sys
from subprocess import Popen, PIPE

mod_re = (r"\bmodule\s+(", r")\s*\(\s*")
func_re = (r"\bfunction\s+(", r")\s*\(")

def extract_definitions(fpath, name_re=r"\w+", def_re=""):
    regex = name_re.join(def_re)
    matcher = re.compile(regex)
    return (m.group(1) for m in matcher.finditer(fpath.read()))

def extract_mod_names(fpath, name_re=r"\w+"):
    return extract_definitions(fpath, name_re=name_re, def_re=mod_re)

def extract_func_names(fpath, name_re=r"\w+"):
    return extract_definitions(fpath, name_re=name_re, def_re=func_re)

def collect_test_modules(dirpath=None):
    dirpath = dirpath or py.path.local("./")
    print("Collecting openscad test module names")

    test_files = {}
    for fpath in dirpath.visit('*.scad'):
        #print(fpath)
        modules = extract_mod_names(fpath, r"test\w*")
        #functions = extract_func_names(fpath, r"test\w*")
        test_files[fpath] = modules
    return test_files

class Timeout(Exception): pass

def call_openscad(path, stlpath, timeout=5):
    if sys.platform == 'darwin': exe = 'OpenSCAD.app/Contents/MacOS/OpenSCAD'
    else: exe = 'openscad'
    command = [exe, '-o', str(stlpath),  str(path)]
    print(command)
    if timeout:
        try:
            proc = Popen(command,
                stdout=PIPE, stderr=PIPE, close_fds=True)
            calltime = time.time()
            time.sleep(0.05)
            #print(calltime)
            while True:
                if proc.poll() is not None:
                    break
                time.sleep(0.5)
                #print(time.time())
                if time.time() > calltime + timeout:
                    raise Timeout()
        finally:
            try:
                proc.terminate()
                proc.kill()
            except OSError:
                pass

        return (proc.returncode,) + proc.communicate()
    else:
        output = subprocess.getstatusoutput(" ".join(command)).decode("utf-8")
        return output + ('', '')

def parse_output(text):
    pass
// This file is placed under the public domain

// from: http://www.thingiverse.com/thing:9512
// Author: nefercheprure

// Examples:
//   standard LEGO 2x1 tile has no pin
//      block(1,2,1/3,reinforcement=false,flat_top=true);
//   standard LEGO 2x1 flat has pin
//      block(1,2,1/3,reinforcement=true);
//   standard LEGO 2x1 brick has pin
//      block(1,2,1,reinforcement=true);
//   standard LEGO 2x1 brick without pin
//      block(1,2,1,reinforcement=false);
//   standard LEGO 2x1x5 brick has no pin and has hollow knobs
//      block(1,2,5,reinforcement=false,hollow_knob=true);


knob_diameter=4.8;		//knobs on top of blocks
knob_height=2;
knob_spacing=8.0;
wall_thickness=1.45;
roof_thickness=1.05;
block_height=9.5;
pin_diameter=3;		//pin for bottom blocks with width or length of 1
post_diameter=6.5;
reinforcing_width=1.5;
axle_spline_width=2.0;
axle_diameter=5;
cylinder_precision=0.5;

/* EXAMPLES:

block(2,1,1/3,axle_hole=false,circular_hole=true,reinforcement=true,hollow_knob=true,flat_top=true);

translate([50,-10,0])
	block(1,2,1/3,axle_hole=false,circular_hole=true,reinforcement=false,hollow_knob=true,flat_top=true);

translate([10,0,0])
	block(2,2,1/3,axle_hole=false,circular_hole=true,reinforcement=true,hollow_knob=true,flat_top=true);
translate([30,0,0])
	block(2,2,1/3,axle_hole=false,circular_hole=true,reinforcement=true,hollow_knob=false,flat_top=false);
translate([50,0,0])
	block(2,2,1/3,axle_hole=false,circular_hole=true,reinforcement=true,hollow_knob=true,flat_top=false);
translate([0,20,0])
	block(3,2,2/3,axle_hole=false,circular_hole=true,reinforcement=true,hollow_knob=true,flat_top=false);
translate([20,20,0])
	block(3,2,1,axle_hole=true,circular_hole=false,reinforcement=true,hollow_knob=false,flat_top=false);
translate([40,20,0])
	block(3,2,1/3,axle_hole=false,circular_hole=false,reinforcement=false,hollow_knob=false,flat_top=false);
translate([0,-10,0])
	block(1,5,1/3,axle_hole=true,circular_hole=false,reinforcement=true,hollow_knob=false,flat_top=false);
translate([0,-20,0])
	block(1,5,1/3,axle_hole=true,circular_hole=false,reinforcement=true,hollow_knob=true,flat_top=false);
translate([0,-30,0])
	block(1,5,1/3,axle_hole=true,circular_hole=false,reinforcement=true,hollow_knob=true,flat_top=true);
//*/

module block(width,length,height,axle_hole=false,reinforcement=false, hollow_knob=false, flat_top=false, circular_hole=false, solid_bottom=true, center=false) {
	overall_length=(length-1)*knob_spacing+knob_diameter+wall_thickness*2;
	overall_width=(width-1)*knob_spacing+knob_diameter+wall_thickness*2;
	center= center==true ? 1 : 0;
	translate(center*[-overall_length/2, -overall_width/2, 0])
	union() {
		difference() {
			union() {
				// body:
				cube([overall_length,overall_width,height*block_height]);
				// knobs:
				if (flat_top != true)
				translate([knob_diameter/2+wall_thickness,knob_diameter/2+wall_thickness,0]) 
					for (ycount=[0:width-1])
						for (xcount=[0:length-1]) {
							translate([xcount*knob_spacing,ycount*knob_spacing,0])
								difference() {
									cylinder(r=knob_diameter/2,h=block_height*height+knob_height,$fs=cylinder_precision);
									if (hollow_knob==true)
										translate([0,0,-roof_thickness])
											cylinder(r=pin_diameter/2,h=block_height*height+knob_height+2*roof_thickness,$fs=cylinder_precision);
								}
					}
			}
			// hollow bottom:
			if (solid_bottom == false)
				translate([wall_thickness,wall_thickness,-roof_thickness]) cube([overall_length-wall_thickness*2,overall_width-wall_thickness*2,block_height*height]);
			// flat_top -> groove around bottom
			if (flat_top == true) {
				translate([-wall_thickness/2,-wall_thickness*2/3,-wall_thickness/2])
					cube([overall_length+wall_thickness,wall_thickness,wall_thickness]);
				translate([-wall_thickness/2,overall_width-wall_thickness/3,-wall_thickness/2])
					cube([overall_length+wall_thickness,wall_thickness,wall_thickness]);
	
				translate([-wall_thickness*2/3,-wall_thickness/2,-wall_thickness/2])
					cube([wall_thickness,overall_width+wall_thickness,wall_thickness]);
				translate([overall_length-wall_thickness/3,0,-wall_thickness/2])
					cube([wall_thickness,overall_width+wall_thickness,wall_thickness]);
			}
			if (axle_hole==true)
				if (width>1 && length>1) for (ycount=[1:width-1])
					for (xcount=[1:length-1])
						translate([xcount*knob_spacing,ycount*knob_spacing,roof_thickness])  axle(height);
			if (circular_hole==true)
				if (width>1 && length>1) for (ycount=[1:width-1])
					for (xcount=[1:length-1])
						translate([xcount*knob_spacing,ycount*knob_spacing,roof_thickness])
							cylinder(r=knob_diameter/2, h=height*block_height+roof_thickness/4,$fs=cylinder_precision);
		}

		if (reinforcement==true && width>1 && length>1)
			difference() {
				for (ycount=[1:width-1])
					for (xcount=[1:length-1])
						translate([xcount*knob_spacing,ycount*knob_spacing,0]) reinforcement(height);
				for (ycount=[1:width-1])
					for (xcount=[1:length-1])
						translate([xcount*knob_spacing,ycount*knob_spacing,-roof_thickness/2]) cylinder(r=knob_diameter/2, h=height*block_height+roof_thickness, $fs=cylinder_precision);
			}
		// posts:
		if (solid_bottom == false)
			if (width>1 && length>1) for (ycount=[1:width-1])
				for (xcount=[1:length-1])
					translate([xcount*knob_spacing,ycount*knob_spacing,0]) post(height);

		if (reinforcement == true && width==1 && length!=1)
			for (xcount=[1:length-1])
				translate([xcount*knob_spacing,overall_width/2,0]) cylinder(r=pin_diameter/2,h=block_height*height,$fs=cylinder_precision);

		if (reinforcement == true && length==1 && width!=1)
			for (ycount=[1:width-1])
				translate([overall_length/2,ycount*knob_spacing,0]) cylinder(r=pin_diameter/2,h=block_height*height,$fs=cylinder_precision);
	}
}

module post(height) {
	difference() {
		cylinder(r=post_diameter/2, h=height*block_height-roof_thickness/2,$fs=cylinder_precision);
		translate([0,0,-roof_thickness/2])
			cylinder(r=knob_diameter/2, h=height*block_height+roof_thickness/4,$fs=cylinder_precision);
	}
}

module reinforcement(height) {
	union() {
		translate([0,0,height*block_height/2]) union() {
			cube([reinforcing_width,knob_spacing+knob_diameter+wall_thickness/2,height*block_height],center=true);
			rotate(v=[0,0,1],a=90) cube([reinforcing_width,knob_spacing+knob_diameter+wall_thickness/2,height*block_height], center=true);
		}
	}
}

module axle(height) {
	translate([0,0,height*block_height/2]) union() {
		cube([axle_diameter,axle_spline_width,height*block_height],center=true);
		cube([axle_spline_width,axle_diameter,height*block_height],center=true);
	}
}
			
// Copyright 2010 D1plo1d

// This library is dual licensed under the GPL 3.0 and the GNU Lesser General Public License as per http://creativecommons.org/licenses/LGPL/2.1/ .

include <math.scad>


//generates a motor mount for the specified nema standard #.
module stepper_motor_mount(nema_standard,slide_distance=0, mochup=true, tolerance=0) {
	//dimensions from:
	// http://www.numberfactory.com/NEMA%20Motor%20Dimensions.htm
	if (nema_standard == 17)
	{
		_stepper_motor_mount(
			motor_shaft_diameter = 0.1968*mm_per_inch,
			motor_shaft_length = 0.945*mm_per_inch,
			pilot_diameter = 0.866*mm_per_inch,
			pilot_length = 0.80*mm_per_inch,
			mounting_bolt_circle = 1.725*mm_per_inch,
			bolt_hole_size = 3.5,
			bolt_hole_distance = 1.220*mm_per_inch,
			slide_distance = slide_distance,
			mochup = mochup,
			tolerance=tolerance);
	}
	if (nema_standard == 23)
	{
		_stepper_motor_mount(
			motor_shaft_diameter = 0.250*mm_per_inch,
			motor_shaft_length = 0.81*mm_per_inch,
			pilot_diameter = 1.500*mm_per_inch,
			pilot_length = 0.062*mm_per_inch,
			mounting_bolt_circle = 2.625*mm_per_inch,
			bolt_hole_size = 0.195*mm_per_inch,
			bolt_hole_distance = 1.856*mm_per_inch,
			slide_distance = slide_distance,
			mochup = mochup,
			tolerance=tolerance);
	}
	
}


//inner mehod for creating a stepper motor mount of any dimensions
module _stepper_motor_mount(
	motor_shaft_diameter,
	motor_shaft_length,
	pilot_diameter,
	pilot_length,
	mounting_bolt_circle,
	bolt_hole_size,
	bolt_hole_distance,
	slide_distance = 0,
	motor_length = 40, //arbitray - not standardized
	mochup,
	tolerance = 0
)
{
	union()
	{
	// == centered mount points ==
	//mounting circle inset
	translate([0,slide_distance/2,0]) circle(r = pilot_diameter/2 + tolerance);
	square([pilot_diameter,slide_distance],center=true);
	translate([0,-slide_distance/2,0]) circle(r = pilot_diameter/2 + tolerance);

	//todo: motor shaft hole
	
	//mounting screw holes
	for (x = [-1,1])
	{
		for (y = [-1,1])
		{
			translate([x*bolt_hole_distance/2,y*bolt_hole_distance/2,0])
			{
				translate([0,slide_distance/2,0]) circle(bolt_hole_size/2 + tolerance);
				translate([0,-slide_distance/2,0]) circle(bolt_hole_size/2 + tolerance);
				square([bolt_hole_size+2*tolerance,slide_distance],center=true);
			}
		}
	}
	// == motor mock-up ==
	//motor box
	if (mochup == true)
	{
		%translate([0,0,-5]) cylinder(h = 5, r = pilot_diameter/2);
		%translate(v=[0,0,-motor_length/2])
		{
			cube(size=[bolt_hole_distance+bolt_hole_size+5,bolt_hole_distance+bolt_hole_size+5,motor_length], center = true);
		}
		//shaft
		%translate(v=[0,0,-(motor_length-motor_shaft_length-2)/2])
		{
			%cylinder(r=motor_shaft_diameter/2,h=motor_length+motor_shaft_length--1, center = true);
		}
	}
	}
}
/*
 * Material colors.
 * 
 * Originally by Hans Häggström, 2010.
 * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later
 */

// Material colors
Oak = [0.65, 0.5, 0.4];
Pine = [0.85, 0.7, 0.45];
Birch = [0.9, 0.8, 0.6];
FiberBoard = [0.7, 0.67, 0.6];
BlackPaint = [0.2, 0.2, 0.2];
Iron = [0.36, 0.33, 0.33];
Steel = [0.65, 0.67, 0.72];
Stainless = [0.45, 0.43, 0.5];
Aluminum = [0.77, 0.77, 0.8];
Brass = [0.88, 0.78, 0.5];
Transparent = [1, 1, 1, 0.2];

// Example, uncomment to view
//color_demo();

module color_demo(){
    // Wood
    colorTest(Oak, 0, 0);
    colorTest(Pine, 1, 0);
    colorTest(Birch, 2, 0);

    // Metals
    colorTest(Iron, 0, 1);
    colorTest(Steel, 1, 1);
    colorTest(Stainless, 2, 1);
    colorTest(Aluminum, 3, 1);

    // Mixboards
    colorTest(FiberBoard, 0, 2);

    // Paints
    colorTest(BlackPaint, 0, 3);
}

module colorTest(col, row=0, c=0) {
  color(col) translate([row * 30,c*30,0]) sphere(r=10);
}
//===========================================
//   Public Domain Epi- and Hypo- trochoids in OpenSCAD
//   version 1.0
//   by Matt Moses, 2011, mmoses152@gmail.com
//   http://www.thingiverse.com/thing:8067
//
//   This file is public domain.  Use it for any purpose, including commercial
//   applications.  Attribution would be nice, but is not required.  There is
//   no warranty of any kind, including its correctness, usefulness, or safety.
//
//   An EPITROCHOID is a curve traced by a point 
//   fixed at a distance "d" 
//   to the center of a circle of radius "r"
//   as the circle rolls 
//   outside another circle of radius "R".
//
//   An HYPOTROCHOID is a curve traced by a point 
//   fixed at a distance "d" 
//   to the center of a circle of radius "r"
//   as the circle rolls 
//   inside another circle of radius "R".
//
//   An EPICYCLOID is an epitrochoid with d = r.
//
//   An HYPOCYCLOID is an hypotrochoid with d = r.
//
//   See http://en.wikipedia.org/wiki/Epitrochoid
//   and http://en.wikipedia.org/wiki/Hypotrochoid
// 
//   Beware the polar forms of the equations on Wikipedia...
//   They are correct, but theta is measured to the center of the small disk!!
//===========================================

// There are several different methods for extruding.  The best are probably
// the ones using linear extrude.


//===========================================
//   Demo - draws one of each, plus some little wheels and sticks.
//
//   Fun stuff to try: 
//   Animate, try FPS = 5 and Steps = 200
//   R = 2, r = 1, d = 0.2
//   R = 4, r = 1, d = 1
//   R = 2, r = 1, d = 0.5
//   
//   What happens when you make d > r ??
//   What happens when d < 0 ??
//   What happens when r < 0 ??
//
//===========================================

$fn = 30;

thickness = 2;
R = 4;
r = 1;
d = 1;
n = 60; // number of wedge segments

alpha = 360*$t;

color([0, 0, 1])
translate([0, 0, -0.5])
	cylinder(h = 1, r= R, center = true);

color([0, 1, 0])
epitrochoid(R,r,d,n,thickness);

color([1, 0, 0])
translate([ (R+r)*cos(alpha) , (R+r)*sin(alpha), -0.5]) {
	rotate([0, 0, alpha + R/r*alpha]) {
		cylinder(h = 1, r = r, center = true);
		translate([-d, 0, 1.5]) {
			cylinder(h = 2.2, r = 0.1, center = true);
		}
	}
}


translate([2*(abs(R) + abs(r) + abs(d)), 0, 0]){
color([0, 0, 1])
translate([0, 0, -0.5])
	difference() {
		cylinder(h = 1, r = 1.1*R, center = true);
		cylinder(h = 1.1, r= R, center = true);
	}

color([0, 1, 0])
hypotrochoid(R,r,d,n,thickness);

color([1, 0, 0])
translate([ (R-r)*cos(alpha) , (R-r)*sin(alpha), -0.5]) {
	rotate([0, 0, alpha - R/r*alpha]) {
		cylinder(h = 1, r = r, center = true);
		translate([d, 0, 1.5]) {
			cylinder(h = 2.2, r = 0.1, center = true);
		}
	}
}
}

// This just makes a twisted hypotrochoid
translate([0,14, 0])
hypotrochoidLinear(4, 1, 1, 40, 40, 10, 30);

//   End of Demo Section
//===========================================


//===========================================
// Epitrochoid
//
module epitrochoid(R, r, d, n, thickness) {
	dth = 360/n;
	for ( i = [0:n-1] ) {
			polyhedron(points = [[0,0,0], 
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i), 0], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1)), 0], 
			[0,0,thickness], 
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i), thickness], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1)), thickness]],
			triangles = [[0, 2, 1], 
			[0, 1,  3], 
			[3, 1, 4], 
			[3, 4, 5], 
			[0, 3, 2], 
			[2, 3, 5],
			[1, 2, 4],
			[2, 5, 4]]);
	}
}
//===========================================


//===========================================
// Hypotrochoid
//
module hypotrochoid(R, r, d, n, thickness) {
	dth = 360/n;
	for ( i = [0:n-1] ) {
			polyhedron(points = [[0,0,0], 
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i), 0], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1)), 0], 
			[0,0,thickness], 
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i), thickness], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1)), thickness]],
			triangles = [[0, 2, 1], 
			[0, 1,  3], 
			[3, 1, 4], 
			[3, 4, 5], 
			[0, 3, 2], 
			[2, 3, 5],
			[1, 2, 4],
			[2, 5, 4]]);
	}
}
//===========================================


//===========================================
// Epitrochoid Wedge with Bore
//
module epitrochoidWBore(R, r, d, n, p, thickness, rb) {
	dth = 360/n;
	union() {
	for ( i = [0:p-1] ) {
			polyhedron(points = [[rb*cos(dth*i), rb*sin(dth*i),0], 
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i), 0], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1)), 0], 
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1)), 0], 
			[rb*cos(dth*i), rb*sin(dth*i), thickness],
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i), thickness], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1)), thickness],
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1)), thickness]],
			triangles = [[0, 1, 4], [4, 1, 5],
			[1, 2, 5], [5, 2, 6], 
			[2, 3, 7], [7, 6, 2], 
			[3, 0, 4], [4, 7, 3], 
			[4, 5, 7], [7, 5, 6], 
			[0, 3, 1], [1, 3, 2]]); 
	}
	}
}
//===========================================


//===========================================
// Epitrochoid Wedge with Bore, Linear Extrude
//
module epitrochoidWBoreLinear(R, r, d, n, p, thickness, rb, twist) {
	dth = 360/n;
	linear_extrude(height = thickness, convexity = 10, twist = twist) {
	union() {
	for ( i = [0:p-1] ) {
			polygon(points = [[rb*cos(dth*i), rb*sin(dth*i)], 
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i)], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1))], 
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1))]],
			paths = [[0, 1, 2, 3]], convexity = 10); 
	}
	}
	}
}
//===========================================


//===========================================
// Epitrochoid Wedge, Linear Extrude
//
module epitrochoidLinear(R, r, d, n, p, thickness, twist) {
	dth = 360/n;
	linear_extrude(height = thickness, convexity = 10, twist = twist) {
	union() {
	for ( i = [0:p-1] ) {
			polygon(points = [[0, 0], 
			[(R+r)*cos(dth*i) - d*cos((R+r)/r*dth*i), (R+r)*sin(dth*i) - d*sin((R+r)/r*dth*i)], 
			[(R+r)*cos(dth*(i+1)) - d*cos((R+r)/r*dth*(i+1)), (R+r)*sin(dth*(i+1)) - d*sin((R+r)/r*dth*(i+1))]], 
			paths = [[0, 1, 2]], convexity = 10); 
	}
	}
	}
}
//===========================================


//===========================================
// Hypotrochoid Wedge with Bore
//
module hypotrochoidWBore(R, r, d, n, p, thickness, rb) {
	dth = 360/n;
	union() {
	for ( i = [0:p-1] ) {
			polyhedron(points = [[rb*cos(dth*i), rb*sin(dth*i),0], 
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i), 0], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1)), 0], 
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1)), 0], 
			[rb*cos(dth*i), rb*sin(dth*i), thickness],
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i), thickness], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1)), thickness],
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1)), thickness]],
			triangles = [[0, 1, 4], [4, 1, 5],
			[1, 2, 5], [5, 2, 6], 
			[2, 3, 7], [7, 6, 2], 
			[3, 0, 4], [4, 7, 3], 
			[4, 5, 7], [7, 5, 6], 
			[0, 3, 1], [1, 3, 2]]); 
	}
	}
}
//===========================================


//===========================================
// Hypotrochoid Wedge with Bore, Linear Extrude
//
module hypotrochoidWBoreLinear(R, r, d, n, p, thickness, rb, twist) {
	dth = 360/n;
	linear_extrude(height = thickness, convexity = 10, twist = twist) {
	union() {
	for ( i = [0:p-1] ) {
			polygon(points = [[rb*cos(dth*i), rb*sin(dth*i)], 
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i)], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1))], 
			[rb*cos(dth*(i+1)), rb*sin(dth*(i+1))]], 
			paths = [[0, 1, 2, 3]], convexity = 10); 
	}
	}
	}
}
//===========================================


//===========================================
// Hypotrochoid Wedge, Linear Extrude
//
module hypotrochoidLinear(R, r, d, n, p, thickness, twist) {
	dth = 360/n;
	linear_extrude(height = thickness, convexity = 10, twist = twist) {
	union() {
	for ( i = [0:p-1] ) {
			polygon(points = [[0, 0], 
			[(R-r)*cos(dth*i) + d*cos((R-r)/r*dth*i), (R-r)*sin(dth*i) - d*sin((R-r)/r*dth*i)], 
			[(R-r)*cos(dth*(i+1)) + d*cos((R-r)/r*dth*(i+1)), (R-r)*sin(dth*(i+1)) - d*sin((R-r)/r*dth*(i+1))]],
			paths = [[0, 1, 2]], convexity = 10); 
	}
	}
	}
}
//=========================================== 
OpenSCAD MCAD Library
=====================

This library contains components commonly used in designing and mocking up
mechanical designs. It is currently unfinished and you can expect some API
changes, however many things are already working.

This library was created by various authors as named in the individual
files' comments. All the files are licensed under the LGPL 2.1 (see
http://creativecommons.org/licenses/LGPL/2.1/ or the included file
lgpl-2.1.txt), some of them allow distribution under more permissive
terms (as described in the files' comments).

## Usage ##

You can import these files in your scripts with `use <MCAD/filename.scad>`, 
where 'filename' is one of the files listed below like 'motors' or 
'servos'. Some files include useful constants which will be available 
with `include <MCAD/filename.scad>`, which should be safe to use on all 
included files (ie. no top level code should create geometry). (There is 
a bug/feature that prevents including constants from files that 
"include" other files - see the openscad mailing list archives for more 
details. Since the maintainers aren't very responsive, may have to work 
around this somehow)

If you host your project in git, you can do `git submodule add URL PATH` in your
repo to import this library as a git submodule for easy usage. Then you need to do
a `git submodule update --init` after cloning. When you want to update the submodule,
do `cd PATH; git checkout master; git pull`. See `git help submodule` for more info.

Currently Provided Tools:

* regular_shapes.scad
    - regular polygons, ie. 2D
    - regular polyhedrons, ie. 3D

* involute_gears.scad (http://www.thingiverse.com/thing:3575):
    - gear()
    - bevel_gear()
    - bevel_gear_pair()

* gears.scad (Old version):
    - gear(number_of_teeth, circular_pitch OR diametrial_pitch, pressure_angle OPTIONAL, clearance OPTIONAL)

* motors.scad:
    - stepper_motor_mount(nema_standard, slide_distance OPTIONAL, mochup OPTIONAL)

Tools (alpha and beta quality):

* nuts_and_bolts.scad: for creating metric and imperial bolt/nut holes
* bearing.scad: standard/custom bearings
* screw.scad: screws and augers
* materials.scad: color definitions for different materials
* stepper.scad: NEMA standard stepper outlines
* servos.scad: servo outlines
* boxes.scad: box with rounded corners
* triangles.scad: simple triangles
* 3d_triangle.scad: more advanced triangles

Very generally useful functions and constants:

* math.scad: general math functions
* constants.scad: mathematical constants
* curves.scad: mathematical functions defining curves
* units.scad: easy metric units
* utilities.scad: geometric funtions and misc. useful stuff
* teardrop.scad (http://www.thingiverse.com/thing:3457): parametric teardrop module
* shapes.scad: DEPRECATED simple shapes by Catarina Mota
* polyholes.scad: holes that should come out well when printed

Other:

* alphabet_block.scad
* bitmap.scad
* letter_necklace.scad
* name_tag.scad
* height_map.scad
* trochoids.scad
* libtriangles.scad
* layouts.scad
* transformations.scad
* 2Dshapes.scad
* gridbeam.scad
* fonts.scad
* unregular_shapes.scad
* metric_fastners.scad
* lego_compatibility.scad
* multiply.scad
* hardware.scad

External utils that generate and process openscad code:

* openscad_testing.py: testing code, see below
* openscad_utils.py: code for scraping function names etc.

## Development ##

You are welcome to fork this project in github and request pulls. I will try to
accomodate the community as much as possible in this. If for some reason you
want collaborator access, just ask.

Github is fun (and easy), but I can include code submissions and other
improvements directly, and have already included code from various sources
(thingiverse is great :)

### Code style ###
I'd prefer to have all included code nicely indented, at least at the block
level, and no extraneous whitespace. I'm used to indent with four spaces as
opposed to tabs or other mixes of whitespace, but at least try to choose a style
and stick to it.

### Testing ###
I've started a minimal testing infrastucture for OpenSCAD code. It's written in
python and uses py.test (might be compatible with Nose also). Just type `py.test`
inside the lib dir in a terminal and you should see a part of the tests passing
and tracebacks for failing tests. It's very simplistic still, but it should test
that no syntax errors occur at least.

The code is included in openscad_testing.py, and can be imported to be
used in other codebases.
// MIT license
// Author: Elmo Mäntynen

TAU = 6.2831853071; //2*PI, see http://tauday.com/
PI = TAU/2;

// translates a imperial measurement in inches to meters
mm_per_inch = 25.4;

import py
import os.path

dirpath = py.path.local("./")

def pytest_generate_tests(metafunc):
    names = []
    if "filename" in metafunc.funcargnames:
        for fpath in dirpath.visit('*.scad'):
            names.append(fpath.basename)
        for fpath in dirpath.visit('*.py'):
            name = fpath.basename
            if not (name.startswith('test_') or name.startswith('_')):
                names.append(name)
    metafunc.parametrize("filename", names)

def test_README(filename):
    README = dirpath.join('README.markdown').read()

    assert filename in README
//By Glen Chung, 2013.
//Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later

include <MCAD/units.scad>
include <MCAD/materials.scad>

LINEAR_BEARING_dr = 0;  //Inscribed circle
LINEAR_BEARING_D  = 1;  //Outer diameter
LINEAR_BEARING_L  = 2;  //Length
LINEAR_BEARING_B  = 3;  //Outer locking groove B
LINEAR_BEARING_D1 = 4;  //Outer locking groove D1
LINEAR_BEARING_W  = 5;  //W


// Common bearing names
LinearBearing = "LM8UU";

// Linear Bearing dimensions
//  model == "XXXXX"   ?   [    dr,      D,      L,        B,      D1,       W]:
function linearBearingDimensions(model) =
    model == "LM3UU"   ?   [  3*mm,   7*mm,  10*mm,   0.0*mm,   0.0*mm, 0.00*mm]:
    model == "LM4UU"   ?   [  4*mm,   8*mm,  12*mm,   0.0*mm,   0.0*mm, 0.00*mm]:
    model == "LM5UU"   ?   [  5*mm,  10*mm,  15*mm,  10.2*mm,   9.6*mm, 1.10*mm]:
    model == "LM6UU"   ?   [  6*mm,  12*mm,  19*mm,  13.5*mm,  11.5*mm, 1.10*mm]:
    model == "LM8SUU"  ?   [  8*mm,  15*mm,  17*mm,  11.5*mm,  14.3*mm, 1.10*mm]:
    model == "LM10UU"  ?   [ 10*mm,  19*mm,  29*mm,  22.0*mm,  18.0*mm, 1.30*mm]:
    model == "LM12UU"  ?   [ 12*mm,  21*mm,  30*mm,  23.0*mm,  20.0*mm, 1.30*mm]:
    model == "LM13UU"  ?   [ 13*mm,  23*mm,  32*mm,  23.0*mm,  22.0*mm, 1.30*mm]:
    model == "LM16UU"  ?   [ 16*mm,  28*mm,  37*mm,  26.5*mm,  27.0*mm, 1.60*mm]:
    model == "LM20UU"  ?   [ 20*mm,  32*mm,  42*mm,  30.5*mm,  30.5*mm, 1.60*mm]:
    model == "LM25UU"  ?   [ 25*mm,  40*mm,  59*mm,  41.0*mm,  38.0*mm, 1.85*mm]:
    model == "LM30UU"  ?   [ 30*mm,  45*mm,  64*mm,  44.5*mm,  43.0*mm, 1.85*mm]:
    model == "LM35UU"  ?   [ 35*mm,  52*mm,  70*mm,  49.5*mm,  49.0*mm, 2.10*mm]:
    model == "LM40UU"  ?   [ 40*mm,  60*mm,  80*mm,  60.5*mm,  57.0*mm, 2.10*mm]:
    model == "LM50UU"  ?   [ 50*mm,  80*mm, 100*mm,  74.0*mm,  76.5*mm, 2.60*mm]:
    model == "LM60UU"  ?   [ 60*mm,  90*mm, 110*mm,  85.0*mm,  86.5*mm, 3.15*mm]:
    model == "LM80UU"  ?   [ 80*mm, 120*mm, 140*mm, 105.5*mm, 116.0*mm, 4.15*mm]:
    model == "LM100UU" ?   [100*mm, 150*mm, 150*mm, 125.5*mm, 145.0*mm, 4.15*mm]:
  /*model == "LM8UU"   ?*/ [  8*mm,  15*mm,  24*mm,  17.5*mm,  14.3*mm, 1.10*mm];


function linearBearing_dr(model) = linearBearingDimensions(model)[LINEAR_BEARING_dr];
function linearBearing_D(model)  = linearBearingDimensions(model)[LINEAR_BEARING_D];
function linearBearing_L(model)  = linearBearingDimensions(model)[LINEAR_BEARING_L];
function linearBearing_B(model)  = linearBearingDimensions(model)[LINEAR_BEARING_B];
function linearBearing_D1(model) = linearBearingDimensions(model)[LINEAR_BEARING_D1];
function linearBearing_W(model)  = linearBearingDimensions(model)[LINEAR_BEARING_W];

module linearBearing(pos=[0,0,0], angle=[0,0,0], model=LinearBearing,
                material=Steel, sideMaterial=BlackPaint) {
  dr = linearBearing_dr(model);
  D  = linearBearing_D(model);
  L  = linearBearing_L(model);
  B  = linearBearing_B(model);
  D1 = linearBearing_D1(model);
  W  = linearBearing_W(model);

  innerRim = dr + (D - dr) * 0.2;
  outerRim = D - (D - dr) * 0.2;
  midSink = W/4;

  translate(pos) rotate(angle) union() {
    color(material)
      difference() {
        // Basic ring
        Ring([0,0,0], D, dr, L, material, material);

        if(W) {
          // Side shields
          Ring([0,0,-epsilon], outerRim, innerRim, L*epsilon+midSink, sideMaterial, material);
          Ring([0,0,L-midSink-epsilon], outerRim, innerRim, L*epsilon+midSink, sideMaterial, material);
          //Outer locking groove
          Ring([0,0,(L-B)/2], D+epsilon, outerRim+W/2, W, material, material);
          Ring([0,0,L-(L-B)/2], D+epsilon, outerRim+W/2, W, material, material);
        }
      }
      if(W)
        Ring([0,0,midSink], D-L*epsilon, dr+L*epsilon, L-midSink*2, sideMaterial, sideMaterial);
  }

  module Ring(pos, od, id, h, material, holeMaterial) {
    color(material) {
      translate(pos)
        difference() {
          cylinder(r=od/2, h=h,  $fn = 100);
          color(holeMaterial)
            translate([0,0,-10*epsilon])
              cylinder(r=id/2, h=h+20*epsilon,  $fn = 100);
        }
    }
  }

}


//examples
//linearBearing(model="LM8UU");
//linearBearing(model="LM10UU");
/* From http://www.thingiverse.com/thing:3457
   © 2010 whosawhatsis

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/*
This script generates a teardrop shape at the appropriate angle to prevent overhangs greater than 45 degrees. The angle is in degrees, and is a rotation around the Y axis. You can then rotate around Z to point it in any direction. Rotation around X or Y will cause the angle to be wrong.
*/

module teardrop(radius, length, angle) {
	rotate([0, angle, 0]) union() {
		linear_extrude(height = length, center = true, convexity = radius, twist = 0)
			circle(r = radius, $fn = 30);
		linear_extrude(height = length, center = true, convexity = radius, twist = 0)
			projection(cut = false) rotate([0, -angle, 0]) translate([0, 0, radius * sin(45) * 1.5]) cylinder(h = radius * sin(45), r1 = radius * sin(45), r2 = 0, center = true, $fn = 30);
	}
		
	//I worked this portion out when a bug was causing the projection above to take FOREVER to calculate. It works as a replacement, and I figured I'd leave it here just in case.
	/*
		#polygon(points = [[radius * cos(-angle / 2), radius * sin(-angle / 2), 0],[radius * cos(-angle / 2), radius * -sin(-angle / 2), 0],[(sin(-angle - 45) + cos(-angle - 45)) * radius, 0, 0]], paths = [[0, 1, 2]]);
		#polygon(points = [[radius * -cos(-angle / 2), radius * sin(-angle / 2), 0],[radius * -cos(-angle / 2), radius * -sin(-angle / 2), 0],[(sin(-angle - 45) + cos(-angle - 45)) * radius, 0, 0]], paths = [[0, 1, 2]]);
		#polygon(points = [[radius * sin(-angle / 2), radius * cos(-angle / 2), 0],[radius * sin(-angle / 2), radius * -cos(-angle / 2), 0],[(sin(-angle - 45) + cos(-angle - 45)) * radius, 0, 0]], paths = [[0, 1, 2]]);
	*/
}

/*
 * Simple intersection method to implement a flat/truncated teardrop
 */
module flat_teardrop(radius, length, angle) {
	intersection() {
		rotate([0, angle, 0]) {
			cube(size=[radius * 2, radius * 2, length], center=true);
		}
		teardrop(radius, length, angle);
	}
}

module test_teardrop(){
    translate([0, -15, 0]) teardrop(5, 20, 90);
    translate([0, 0, 0]) teardrop(5, 20, 60);
    translate([0, 15, 0]) teardrop(5, 20, 45);
}

//test_teardrop();
//    Enhancement of OpenSCAD Primitives Solid with Trinagles 
//    Copyright (C) 2011  Rene BAUMANN, Switzerland
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; If not, see <http://www.gnu.org/licenses/>
//    or write to the Free Software Foundation, Inc., 
//    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
// ================================================================
//
//	File providing functions and modules to draw 3D - triangles 
//	created in the X-Y plane with hight h, using various triangle 
//	specification methods. 
//	Standard traingle geometrical definition  is used. Vertices are named A,B,C, 
//	side a is opposite vertex A a.s.o. the angle at vertex A is named alpha, 
//	B(beta), C(gamma).
//
//	This SW is a contribution to the Free Software Community doing a marvelous
//	job of giving anyone access to knowledge and tools to educate himselfe.
//
//	Author:		Rene Baumann
//	Date:		11.09.2011
//	Edition:	0.3	11.09.2011 For review by Marius
//	Edition:	0.4	11.11.2011 Ref to GPL2.1 added
//
// --------------------------------------------------------------------------------------
//
// ===========================================
//
//	FUNCTION: 		3dtri_sides2coord
//	DESCRIPTION:
//		Enter triangle sides a,b,c and to get the A,B,C - corner
// 		co-ordinates. The trinagle's c-side lies on the x-axis
// 		and A-corner in the co-ordinates center [0,0,0]. Geometry rules
//		required that a + b is greater then c.  The traingle's vertices are
//		computed such that it is located in the X-Y plane,  side c is on the 
//		positive x-axis. 
//	PARAMETER:
//		a	: real		length of side a
//		b	: real		length of side b
//		c	: real		length of side c
//	RETURNS:
//		vertices : [Acord,Bcord,Ccord] Array of vertices coordinates
//
//	COMMENT:
//		vertices = 3dtri_sides2coord (3,4,5);
//		vertices[0] : Acord	vertex A cordinates the like [x,y,z] 
// -------------------------------------------------------------------------------------	
//
function 3dtri_sides2coord (a,b,c) = [
		[0,0,0],
		[c,0,0], 
		[(pow(c,2)+pow(a,2)-pow(b,2))/(2*c),sqrt ( pow(a,2) - 
		   pow((pow(c,2)+pow(a,2)-pow(b,2))/(2*c),2)),0]];
//
//
// ===========================================
//
//	FUNCTION: 		3dtri_centerOfGravityCoord
//	DESCRIPTION:
//		Enter triangle  A,B,C - corner coordinates to get the
//		triangles Center of Gravity coordinates. It is assumed
//		the triangle is parallel to the  X-Y plane. The function 
//		returns always zero for the z-coordinate
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//	RETURNS:
//		CG : [x,y,0] 	Center of gravity coordinate in X-Y-plane
//
//	COMMENT:
//		vertices = 3dtri_sides2coord (3,4,5);
//		cg = 3dtri_centerOfGravityCoord(vertices[0],vertices[1],vertices[2]);
// -------------------------------------------------------------------------------------	
//
function 3dtri_centerOfGravityCoord (Acord,Bcord,Ccord) = [
		(Acord[0]+Bcord[0]+Ccord[0])/3,(Acord[1]+Bcord[1]+Ccord[1])/3,0];
//
//
// ===========================================
//
//	FUNCTION: 		3dtri_centerOfcircumcircle
//	DESCRIPTION:
//		Enter triangle  A,B,C - corner coordinates to get the
//		circum circle coordinates. It is assumed
//		the triangle is parallel to the  X-Y plane. The function 
//		returns always zero for the z-coordinate
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//	RETURNS:
//		cc	: [x,y,0] 	Circumcircle center
//
//	COMMENT:
//		vertices = 3dtri_sides2coord (3,4,5);
//		cc = 3dtri_centerOfcircumcircle (vertices[0],vertices[1],vertices[2]);
// -------------------------------------------------------------------------------------	
//
function 3dtri_centerOfcircumcircle (Acord,Bcord,Ccord) = 
		[0.5*Bcord[0],
		 0.5*((pow(Ccord[1],2)+pow(Ccord[0],2)-Bcord[0]*Ccord[0])/Ccord[1]),
		 0];
//
// 
//
// ===========================================
//
//	FUNCTION: 		3dtri_radiusOfcircumcircle
//	DESCRIPTION:
//		 Provides the triangle's radius from circumcircle  to the vertices.
//		It is assumed the triangle is parallel to the  X-Y plane. The function 
//		returns always zero for the z-coordinate
//	PARAMETER:
//		Vcord	:   [x,y,z] 	Coordinates of a vertex A or B,C
//		CCcord : [x,y,z] 	Coordinates of circumcircle
//		r	: Radius at vertices if round corner triangle used,
//			  else enter "0"
//	RETURNS:
//		cr	: Circumcircle radius
//
//	COMMENT:  Calculate circumcircle radius of trinagle with round vertices having
//			radius R = 2
//		vertices = 3dtri_sides2coord (3,4,5);
//		cc = 3dtri_centerOfcircumcircle (vertices[0],vertices[1],vertices[2]);
//		cr = 3dtri_radiusOfcircumcircle (vertices[0],cc,2); 
// -------------------------------------------------------------------------------------	
//
function 3dtri_radiusOfcircumcircle (Vcord,CCcord,R) = 
		sqrt(pow(CCcord[0]-Vcord[0],2)+pow(CCcord[1]-Vcord[1],2))+ R;
//
//
//
// ===========================================
//
//	FUNCTION: 		3dtri_radiusOfIn_circle
//	DESCRIPTION:
//		Enter triangle  A,B,C - corner coordinates to get the
//		in-circle radius. It is assumed the triangle is parallel to the  
//		X-Y plane. The function always returns zero for the z-coordinate. 
//		Formula used for inner circle radius: r = 2A /(a+b+c)
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//		
//	RETURNS:
//		ir	: real		radius of in-circle
//
//	COMMENT:
//		vertices = 3dtri_sides2coord (3,4,5);
//		ir = 3dtri_radiusOfIn_circle (vertices[0],vertices[1],vertices[2]);
// -------------------------------------------------------------------------------------	
//
function 3dtri_radiusOfIn_circle (Acord,Bcord,Ccord) = 
	Bcord[0]*Ccord[1]/(Bcord[0]+sqrt(pow(Ccord[0]-Bcord[0],2)+pow(Ccord[1],2))+
	sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)));
//
// 
//
// ===========================================
//
//	FUNCTION: 		3dtri_centerOfIn_circle
//	DESCRIPTION:
//		Enter triangle  A,B,C - corner coordinates to get the
//		in-circle coordinates. It is assumed
//		the triangle is parallel to the  X-Y plane. The function 
//		returns always zero for the z-coordinate
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//		r	: real		radius of in-circle
//	RETURNS:
//		ic	: [x,y,0] 	In-circle center co-ordinates
//
//	COMMENT:
//		vertices = 3dtri_sides2coord (3,4,5);
//		ir = 3dtri_radiusOfIn_circle (vertices[0],vertices[1],vertices[2]);
//		ic = 3dtri_centerOfIn_circle (vertices[0],vertices[1],vertices[2],ir);
// -------------------------------------------------------------------------------------	
//
function 3dtri_centerOfIn_circle (Acord,Bcord,Ccord,r) = 
		[(Bcord[0]+sqrt(pow(Ccord[0]-Bcord[0],2)+pow(Ccord[1],2))+
	sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)))/2-sqrt(pow(Ccord[0]-Bcord[0],2)+pow(Ccord[1],2)),r,0];
//
//
// ============================================
//
//	MODULE: 		3dtri_draw
//	DESCRIPTION:
//		 Draw a standard solid triangle with A,B,C - vertices specified by its 
// 		co-ordinates and height "h", as given by the  input parameters. 
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//		h	: real		Height of the triangle
//	RETURNS:
//		none
//
//	COMMENT:
//		You might use the result from function 3dtri_sides2coord
//		to call module 3dtri_draw ( vertices[0],vertices[1],vertices[2], h) 
// -------------------------------------------------------------------------------------	
//
module 3dtri_draw ( Acord, Bcord, Ccord, h) {
polyhedron (points=[Acord,Bcord,Ccord,
					Acord+[0,0,h],Bcord+[0,0,h],Ccord+[0,0,h]],
			triangles=[	[0,1,2],[0,2,3],[3,2,5],
					[3,5,4],[1,5,2],[4,5,1],
					[4,1,0],[0,3,4]]);

};
//
//
// ==============================================
//
//	MODULE: 		3dtri_rnd_draw
//	DESCRIPTION:
//		Draw a round corner triangle with A,B,C - vertices specified by its 
// 		co-ordinates, height h and round vertices having radius "r".
//		As specified by the input parameters.
//		Please note, the tringles side lenght gets extended by "2 * r",
//		and the vertices coordinates define the centers of the 
//		circles with radius "r". 
//	PARAMETER:
//		Acord	: [x,y,z] 	Coordinates of vertex A
//		Bcord	: [x,y,z] 	Coordinates of vertex B
//		Ccord	: [x,y,z] 	Coordinates of vertex C
//		h	: real		Height of the triangle
//		r	: real		Radius from vertices coordinates
//	RETURNS:
//		none
//
//	COMMENT:
//		You might use the result from function 3dtri_sides2coord
//		to call module 3dtri_rnd_draw ( vertices[0],vertices[1],vertices[2], h, r) 
// -------------------------------------------------------------------------------------	
//
module 3dtri_rnd_draw ( Acord, Bcord, Ccord, h, r) {
Avect=Ccord-Bcord;	// vector pointing from vertex B to vertex C
p0=Acord + [0,-r,0];
p1=Bcord + [0,-r,0];
p2=Bcord + [r*Avect[1]/sqrt(pow(Avect[0],2)+pow(Avect[1],2)), 
                    -r*Avect[0]/sqrt(pow(Avect[0],2)+pow(Avect[1],2)) ,0];
p3=Ccord + [r*Avect[1]/sqrt(pow(Avect[0],2)+pow(Avect[1],2)), 
                     -r*Avect[0]/sqrt(pow(Avect[0],2)+pow(Avect[1],2)) ,0];
p4=Ccord +[- r*Ccord[1]/sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)), 
                     r*Ccord[0]/sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)) ,0];
p5=Acord + [- r*Ccord[1]/sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)), 
                     r*Ccord[0]/sqrt(pow(Ccord[0],2)+pow(Ccord[1],2)) ,0];
bottom_triangles = [[0,1,2],[0,2,3],[0,3,4],[0,4,5]];
c_side_triangles = [[7,1,0],[0,6,7]];
a_side_triangles = [[2,8,3],[8,9,3]];
b_side_triangles = [[4,10,5],[10,11,5]];
A_edge_triangles = [[0,5,11],[0,11,6]];
B_edge_triangles = [[1,7,2],[2,7,8]];
C_edge_triangles = [[3,9,4],[9,10,4]];
top_triangles = [[11,7,6],[11,8,7],[11,10,8],[8,10,9]];
union () { 
	polyhedron (points=[p0,p1,p2,p3,p4,p5,
					p0+[0,0,h],p1+[0,0,h],p2+[0,0,h],p3+[0,0,h],p4+[0,0,h],p5+[0,0,h]],
			triangles=[	bottom_triangles[0],bottom_triangles[1],bottom_triangles[2],bottom_triangles[3],
						A_edge_triangles[0],A_edge_triangles[1],
						c_side_triangles[0],c_side_triangles[1],
						B_edge_triangles[0],B_edge_triangles[1],
						a_side_triangles[0],a_side_triangles[1],
						C_edge_triangles[0],C_edge_triangles[1],
						b_side_triangles[0],b_side_triangles[1],
						top_triangles[0],top_triangles[1],top_triangles[2],top_triangles[3]]);
	translate(Acord) cylinder(r1=r,r2=r,h=h,center=false);
	translate(Bcord) cylinder(r1=r,r2=r,h=h,center=false);
	translate(Ccord) cylinder(r1=r,r2=r,h=h,center=false);
};
}
//
// ==============================================
//
// Demo Application - copy into new file and uncomment or uncomment here but
// without uncommenting the use <...> statement, then press F6 - Key 
//
// use <MCAD/3d_triangle.scad>;
//$fn=50;
//  h =4;
//  r=2;
//  echo ("Draws a right angle triangle with its circumcircle and in-circle");
//  echo ("The calculated co-ordinates and radius are show in this console window");
//  echo ("Geometry rules for a right angle triangle say, that the circumcircle is the");
//  echo ("Thales Circle which center must be in the middle of the triangle's c - side");
//  echo ("===========================================");
//  vertices  =  3dtri_sides2coord (30,40,50);
//  echo("A = ",vertices[0],"  B = ",vertices[1],"  C = ",vertices[2]);
//  cg = 3dtri_centerOfGravityCoord (vertices[0],vertices[1],vertices[2]);
//  echo (" Center of gravity = ",cg);
//  cc = 3dtri_centerOfcircumcircle (vertices[0],vertices[1],vertices[2]);
//  echo (" Center of circumcircle = ",cc);
//  cr = 3dtri_radiusOfcircumcircle (vertices[0],cc,r); 
//  echo(" Radius of circumcircle ",cr);
//  ir = 3dtri_radiusOfIn_circle (vertices[0],vertices[1],vertices[2]);
//  echo (" Radius of in-circle = ",ir);
//  ic = 3dtri_centerOfIn_circle (vertices[0],vertices[1],vertices[2],ir);
//  echo (" Center of in-circle = ",ic);
//   translate(cc+[0,0,5*h/2]) difference () {
//  		cylinder (h=5*h,r1=cr+4,r2=cr+4,center=true);
//  		cylinder (h=6*h,r1=cr,r2=cr,center=true);}
//  difference () {
//  	union () {
//  	     difference () {
//   		3dtri_rnd_draw (vertices[0], vertices[1], vertices[2],5*h,r);
//  		scale([0.8,0.8,1]) translate([6,2,4*h])  3dtri_rnd_draw (vertices[0], vertices[1], vertices[2],5*h,r);
//  	     }
//  	     translate (ic+[0,0,5*h]) cylinder(h=10*h,r1=ir+r,r2=ir+r,center=true);
//  	}
//  	translate (ic+[0,0,5*h]) cylinder(h=12*h,r1=0.5*ir,r2=0.5*ir,center=true);
//  }

// License: LGPL 2.1

rodsize = 6;	//threaded/smooth rod diameter in mm
xaxis = 182.5;	//width of base in mm
yaxis = 266.5;	//length of base in mm


screwsize = 3;	//bearing bore/screw diameter in mm
bearingsize = 10;	//outer diameter of bearings in mm
bearingwidth = 4;	//width of bearings in mm


rodpitch = rodsize / 6;
rodnutsize = 0.8 * rodsize;
rodnutdiameter = 1.9 * rodsize;
rodwashersize = 0.2 * rodsize;
rodwasherdiameter = 2 * rodsize;
screwpitch = screwsize / 6;
nutsize = 0.8 * screwsize;
nutdiameter = 1.9 * screwsize;
washersize = 0.2 * screwsize;
washerdiameter = 2 * screwsize;
partthick = 2 * rodsize;
vertexrodspace = 2 * rodsize;


c = [0.3, 0.3, 0.3];
rodendoffset = rodnutsize + rodwashersize * 2 + partthick / 2;
vertexoffset = vertexrodspace + rodendoffset;


renderrodthreads = false;
renderscrewthreads = false;
fn = 36;



module rod(length, threaded) if (threaded && renderrodthreads) {
	linear_extrude(height = length, center = true, convexity = 10, twist = -360 * length / rodpitch, $fn = fn)
		translate([rodsize * 0.1 / 2, 0, 0])
			circle(r = rodsize * 0.9 / 2, $fn = fn);
} else cylinder(h = length, r = rodsize / 2, center = true, $fn = fn);


module screw(length, nutpos, washer, bearingpos = -1) union(){
	translate([0, 0, -length / 2]) if (renderscrewthreads) {
		linear_extrude(height = length, center = true, convexity = 10, twist = -360 * length / screwpitch, $fn = fn)
			translate([screwsize * 0.1 / 2, 0, 0])
				circle(r = screwsize * 0.9 / 2, $fn = fn);
	} else cylinder(h = length, r = screwsize / 2, center = true, $fn = fn);
	render() difference() {
		translate([0, 0, screwsize / 2]) cylinder(h = screwsize, r = screwsize, center = true, $fn = fn);
		translate([0, 0, screwsize]) cylinder(h = screwsize, r = screwsize / 2, center = true, $fn = 6);
	}
	if (washer > 0 && nutpos > 0) {
		washer(nutpos);
		nut(nutpos + washersize);
	} else if (nutpos > 0) nut(nutpos);
	if (bearingpos >= 0) bearing(bearingpos);
}


module bearing(position) render() translate([0, 0, -position - bearingwidth / 2]) union() {
	difference() {
		cylinder(h = bearingwidth, r = bearingsize / 2, center = true, $fn = fn);
		cylinder(h = bearingwidth * 2, r = bearingsize / 2 - 1, center = true, $fn = fn);
	}
	difference() {
		cylinder(h = bearingwidth - 0.5, r = bearingsize / 2 - 0.5, center = true, $fn = fn);
		cylinder(h = bearingwidth * 2, r = screwsize / 2 + 0.5, center = true, $fn = fn);
	}
	difference() {
		cylinder(h = bearingwidth, r = screwsize / 2 + 1, center = true, $fn = fn);
		cylinder(h = bearingwidth + 0.1, r = screwsize / 2, center = true, $fn = fn);
	}
}


module nut(position, washer) render() translate([0, 0, -position - nutsize / 2]) {
	intersection() {
		scale([1, 1, 0.5]) sphere(r = 1.05 * screwsize, center = true);
		difference() {
			cylinder (h = nutsize, r = nutdiameter / 2, center = true, $fn = 6);
			cylinder(r = screwsize / 2, h = nutsize + 0.1, center = true, $fn = fn);
		}
	}
	if (washer > 0) washer(0);
}


module washer(position) render() translate ([0, 0, -position - washersize / 2]) difference() {
	cylinder(r = washerdiameter / 2, h = washersize, center = true, $fn = fn);
	cylinder(r = screwsize / 2, h = washersize + 0.1, center = true, $fn = fn);
}

module rodnut(position, washer) render() translate([0, 0, position]) {
	intersection() {
		scale([1, 1, 0.5]) sphere(r = 1.05 * rodsize, center = true);
		difference() {
			cylinder (h = rodnutsize, r = rodnutdiameter / 2, center = true, $fn = 6);
			rod(rodnutsize + 0.1);
		}
	}
	if (washer == 1 || washer == 4) rodwasher(((position > 0) ? -1 : 1) * (rodnutsize + rodwashersize) / 2);
	if (washer == 2 || washer == 4) rodwasher(((position > 0) ? 1 : -1) * (rodnutsize + rodwashersize) / 2);
}


module rodwasher(position) render() translate ([0, 0, position]) difference() {
	cylinder(r = rodwasherdiameter / 2, h = rodwashersize, center = true, $fn = fn);
	rod(rodwashersize + 0.1);
}


rod(20);
translate([rodsize * 2.5, 0, 0]) rod(20, true);
translate([rodsize * 5, 0, 0]) screw(10, true);
translate([rodsize * 7.5, 0, 0]) bearing();
translate([rodsize * 10, 0, 0]) rodnut();
translate([rodsize * 12.5, 0, 0]) rodwasher();
translate([rodsize * 15, 0, 0]) nut();
translate([rodsize * 17.5, 0, 0]) washer();/*
 *  OpenSCAD 2D Shapes Library (www.openscad.org)
 *  Copyright (C) 2012 Peter Uithoven
 *
 *  License: LGPL 2.1 or later

 *  2D Shapes
 *  ngon(sides, radius, center=false);
 *  complexRoundSquare(size,rads1=[0,0], rads2=[0,0], rads3=[0,0], rads4=[0,0], center=true)
 *  roundedSquare(pos=[10,10],r=2)
 *  ellipsePart(width,height,numQuarters)
 *  donutSlice(innerSize,outerSize, start_angle, end_angle)
 *  pieSlice(size, start_angle, end_angle) //size in radius(es)
 *  ellipse(width, height) {
*/

// Examples - (layouts.scad is required for examples)
// example2DShapes(); use <layouts.scad>;

module example2DShapes() {
    grid(105,105,true,4)
    {
        // ellipse
        ellipse(50,75);

        // part of ellipse (a number of quarters)
        ellipsePart(50,75,3);
        ellipsePart(50,75,2);
        ellipsePart(50,75,1);

        // complexRoundSquare examples
        complexRoundSquare([75,100],[20,10],[20,10],[20,10],[20,10]);
        complexRoundSquare([75,100],[0,0],[0,0],[30,50],[20,10]);
        complexRoundSquare([50,50],[10,20],[10,20],[10,20],[10,20],false);
        complexRoundSquare([100,100]);
        complexRoundSquare([100,100],rads1=[20,20],rads3=[20,20]);

        // pie slice
        pieSlice(50,0,10);
        pieSlice(50,45,190);
        pieSlice([50,20],180,270);

        // donut slice
        donutSlice(20,50,0,350);
        donutSlice(30,50,190,270);
        donutSlice([40,22],[50,30],180,270);
        donutSlice([50,20],50,180,270);
        donutSlice([20,30],[50,40],0,270);
    }
}
// end examples ----------------------

module complexRoundSquare(
    size, // Size
    rads1=[0,0], // Top left radius
    rads2=[0,0], // Top right radius
    rads3=[0,0], // Bottom right radius
    rads4=[0,0], // Bottom left radius
    center=true // center
) {
    width = size[0];
    height = size[1];
    // %square(size=[width, height],center=true);
    x1 = 0-width/2+rads1[0];
    y1 = 0-height/2+rads1[1];
    x2 = width/2-rads2[0];
    y2 = 0-height/2+rads2[1];
    x3 = width/2-rads3[0];
    y3 = height/2-rads3[1];
    x4 = 0-width/2+rads4[0];
    y4 = height/2-rads4[1];

    scs = 0.1; // straight corner size

    x = (center)? 0: width/2;
    y = (center)? 0: height/2;

    translate([x,y,0])
    hull()
    {
        // top left
        if(rads1[0] > 0 && rads1[1] > 0)
            translate([x1,y1])
            mirror([1,0])
            ellipsePart(rads1[0]*2,rads1[1]*2,1);
        else
            translate([x1,y1])
            square(size=[scs, scs]);

        // top right
        if(rads2[0] > 0 && rads2[1] > 0)
            translate([x2,y2])
            ellipsePart(rads2[0]*2,rads2[1]*2,1);
        else
            translate([width/2-scs,0-height/2])
            square(size=[scs, scs]);

        // bottom right
        if(rads3[0] > 0 && rads3[1] > 0)
            translate([x3,y3])
            mirror([0,1])
            ellipsePart(rads3[0]*2,rads3[1]*2,1);
        else
            translate([width/2-scs,height/2-scs])
            square(size=[scs, scs]);

        // bottom left
        if(rads4[0] > 0 && rads4[1] > 0)
            translate([x4,y4])
            rotate([0,0,-180])
            ellipsePart(rads4[0]*2,rads4[1]*2,1);
        else
            #translate([x4,height/2-scs])
            square(size=[scs, scs]);
    }
}

module roundedSquare(pos=[10,10],r=2) {
    minkowski()
    {
        square([pos[0]-r*2,pos[1]-r*2],center=true);


        circle(r=r);
    }
}

// round shapes
// The orientation might change with the implementation of circle...
module ngon(sides, radius, center=false) {
    rotate([0, 0, 360/sides/2])
    circle(r=radius, $fn=sides, center=center);
}

module ellipsePart(width,height,numQuarters) {
    o = 1; //slight overlap to fix a bug
    difference()
    {
        ellipse(width,height);

        if(numQuarters <= 3)
            translate([0-width/2-o,0-height/2-o,0])
            square([width/2+o,height/2+o]);
        if(numQuarters <= 2)
            translate([0-width/2-o,-o,0])
            square([width/2+o,height/2+o*2]);
        if(numQuarters < 2)
            translate([-o,0,0])
            square([width/2+o*2,height/2+o]);
    }
}

module donutSlice(innerSize,outerSize, start_angle, end_angle) {
    difference()
    {
        pieSlice(outerSize, start_angle, end_angle);

        if(len(innerSize) > 1)
             ellipse(innerSize[0]*2,innerSize[1]*2);
        else
            circle(innerSize);
    }
}

module pieSlice(size, start_angle, end_angle) { //size in radius(es)
    rx = len(size) > 1? size[0] : size;
    ry = len(size) > 1? size[1] : size;
    trx = rx* sqrt(2) + 1;
    try = ry* sqrt(2) + 1;
    a0 = (4 * start_angle + 0 * end_angle) / 4;
    a1 = (3 * start_angle + 1 * end_angle) / 4;
    a2 = (2 * start_angle + 2 * end_angle) / 4;
    a3 = (1 * start_angle + 3 * end_angle) / 4;
    a4 = (0 * start_angle + 4 * end_angle) / 4;

    if(end_angle > start_angle)
        intersection() {
        if(len(size) > 1)
            ellipse(rx*2,ry*2);
        else
            circle(rx);
        polygon([
            [0,0],
            [trx * cos(a0), try * sin(a0)],
            [trx * cos(a1), try * sin(a1)],
            [trx * cos(a2), try * sin(a2)],
            [trx * cos(a3), try * sin(a3)],
            [trx * cos(a4), try * sin(a4)],
            [0,0]
        ]);
    }
}

module ellipse(width, height) {
    scale([1, height/width, 1])
    circle(r=width/2);
}
//Copyright (C) 2013 Alex Davies
//License: LGPL 2.1 or later
//todo, make library work with negative lengths by adding triangles to the inside of every surface. basicaly copy and paste the current triangles set and reverse the first and last digit of every triangle. In 4 character traingles switcht the middle ones around as well. Not sure if that' actually useful though.

module rightpyramid(rightpyramidx, rightpyramidy, rightpyramidz) {
	polyhedron ( points = [[0,0,0], 
			[rightpyramidx, 0, 0], 
			[0, rightpyramidy, 0], 
			[rightpyramidx, rightpyramidy, 0],
			[rightpyramidx/2, rightpyramidy, rightpyramidz]], 

	triangles = [[0,1,2],[2,1,3],[4,1,0],[3,1,4],[2,3,4],[0,2,4]]);

}

module cornerpyramid(cornerpyramidx, cornerpyramidy, cornerpyramidz) {
	polyhedron ( points = [[0,0,0], 
			[cornerpyramidx, 0, 0], 
			[0, cornerpyramidy, 0], 
			[cornerpyramidx, cornerpyramidy, 0],
			[0, cornerpyramidy, cornerpyramidz]], 

	triangles = [[0,1,2],[2,1,3],[4,1,0],[3,1,4],[2,3,4],[0,2,4]]);

}

module eqlpyramid(eqlpyramidx, eqlpyramidy, eqlpyramidz) {
	polyhedron ( points = [[0,0,0], 
			[eqlpyramidx, 0, 0], 
			[0, eqlpyramidy, 0], 
			[eqlpyramidx, eqlpyramidy, 0],
			[eqlpyramidx/2, eqlpyramidy/2, eqlpyramidz]], 

	triangles = [[0,1,2],[2,1,3],[4,1,0],[3,1,4],[2,3,4],[0,2,4]]);

}


module rightprism(rightprismx,rightprismy,rightprismz){
	polyhedron ( points = [[0,0,0],
			[rightprismx,0,0],
			[rightprismx,rightprismy,0],
			[0,rightprismy,0],
			[0,rightprismy,rightprismz],
			[0,0,rightprismz]], 
	triangles = [[0,1,2,3],[5,1,0],[5,4,2,1],[4,3,2],[0,3,4,5]]);
}



module eqlprism(rightprismx,rightprismy,rightprismz){
	polyhedron ( points = [[0,0,0],
			[rightprismx,0,0],
			[rightprismx,rightprismy,0],
			[0,rightprismy,0],
			[rightprismx/2,rightprismy,rightprismz],
			[rightprismx/2,0,rightprismz]], 
	triangles = [[0,1,2,3],[5,1,0],[5,4,2,1],[4,3,2],[0,3,4,5]]);
}

// Copyright 2010 D1plo1d
// LGPL 2.1


//test_involute_curve();
//test_gears();
//demo_3d_gears();

// Geometry Sources:
//	http://www.cartertools.com/involute.html
//	gears.py (inkscape extension: /usr/share/inkscape/extensions/gears.py)
// Usage:
//	Diametral pitch: Number of teeth per unit length.
//	Circular pitch: Length of the arc from one tooth to the next
//	Clearance: Radial distance between top of tooth on one gear to bottom of gap on another.

function pitch_circular2diameter(number_of_teeth,circular_pitch) = number_of_teeth * circular_pitch / 180;
function pitch_diametral2diameter(number_of_teeth,diametral_pitch) = number_of_teeth / diametral_pitch;

module gear(number_of_teeth,
		circular_pitch=false, diametral_pitch=false,
		pressure_angle=20, clearance = 0,
		verbose=false)
{
	if(verbose) {
		echo("gear arguments:");
		echo(str("  number_of_teeth: ", number_of_teeth));
		echo(str("  circular_pitch: ", circular_pitch));
		echo(str("  diametral_pitch: ", diametral_pitch));
		echo(str("  pressure_angle: ", pressure_angle));
		echo(str("  clearance: ", clearance));
	}
	if (circular_pitch==false && diametral_pitch==false) echo("MCAD ERROR: gear module needs either a diametral_pitch or circular_pitch");
	if(verbose) echo("gear calculations:");

	//Convert diametrial pitch to our native circular pitch
	circular_pitch = (circular_pitch!=false?circular_pitch:180/diametral_pitch);

	// Pitch diameter: Diameter of pitch circle.
	pitch_diameter  =  pitch_circular2diameter(number_of_teeth,circular_pitch);
	if(verbose) echo (str("  pitch_diameter: ", pitch_diameter));
	pitch_radius = pitch_diameter/2;

	// Base Circle
	base_diameter = pitch_diameter*cos(pressure_angle);
	if(verbose) echo (str("  base_diameter: ", base_diameter));
	base_radius = base_diameter/2;

	// Diametrial pitch: Number of teeth per unit length.
	pitch_diametrial = number_of_teeth / pitch_diameter;
	if(verbose) echo (str("  pitch_diametrial: ", pitch_diametrial));

	// Addendum: Radial distance from pitch circle to outside circle.
	addendum = 1/pitch_diametrial;
	if(verbose) echo (str("  addendum: ", addendum));

	//Outer Circle
	outer_radius = pitch_radius+addendum;
	outer_diameter = outer_radius*2;
	if(verbose) echo (str("  outer_diameter: ", outer_diameter));

	// Dedendum: Radial distance from pitch circle to root diameter
	dedendum = addendum + clearance;
	if(verbose) echo (str("  dedendum: ", dedendum));

	// Root diameter: Diameter of bottom of tooth spaces.
	root_radius = pitch_radius-dedendum;
	root_diameter = root_radius * 2;
	if(verbose) echo (str("  root_diameter: ", root_diameter));

	half_thick_angle = 360 / (4 * number_of_teeth);
	if(verbose) echo (str("  half_thick_angle: ", half_thick_angle));

	union()
	{
		rotate(half_thick_angle) circle($fn=number_of_teeth*2, r=root_radius*1.001);

		for (i= [1:number_of_teeth])
		//for (i = [0])
		{
			rotate([0,0,i*360/number_of_teeth])
			{
				involute_gear_tooth(
					pitch_radius = pitch_radius,
					root_radius = root_radius,
					base_radius = base_radius,
					outer_radius = outer_radius,
					half_thick_angle = half_thick_angle);
			}
		}
	}
}


module involute_gear_tooth(
					pitch_radius,
					root_radius,
					base_radius,
					outer_radius,
					half_thick_angle
					)
{
	pitch_to_base_angle  = involute_intersect_angle( base_radius, pitch_radius );

	outer_to_base_angle = involute_intersect_angle( base_radius, outer_radius );

	base1 = 0 - pitch_to_base_angle - half_thick_angle;
	pitch1 = 0 - half_thick_angle;
	outer1 = outer_to_base_angle - pitch_to_base_angle - half_thick_angle;

	b1 = polar_to_cartesian([ base1, base_radius ]);
	p1 = polar_to_cartesian([ pitch1, pitch_radius ]);
	o1 = polar_to_cartesian([ outer1, outer_radius ]);

	b2 = polar_to_cartesian([ -base1, base_radius ]);
	p2 = polar_to_cartesian([ -pitch1, pitch_radius ]);
	o2 = polar_to_cartesian([ -outer1, outer_radius ]);

	// ( root_radius > base_radius variables )
		pitch_to_root_angle = pitch_to_base_angle - involute_intersect_angle(base_radius, root_radius );
		root1 = pitch1 - pitch_to_root_angle;
		root2 = -pitch1 + pitch_to_root_angle;
		r1_t =  polar_to_cartesian([ root1, root_radius ]);
		r2_t =  polar_to_cartesian([ -root1, root_radius ]);

	// ( else )
		r1_f =  polar_to_cartesian([ base1, root_radius ]);
		r2_f =  polar_to_cartesian([ -base1, root_radius ]);

	if (root_radius > base_radius)
	{
		//echo("true");
		polygon( points = [
			r1_t,p1,o1,o2,p2,r2_t
		], convexity = 3);
	}
	else
	{
		polygon( points = [
			r1_f, b1,p1,o1,o2,p2,b2,r2_f
		], convexity = 3);
	}

}

// Mathematical Functions
//===============

// Finds the angle of the involute about the base radius at the given distance (radius) from it's center.
//source: http://www.mathhelpforum.com/math-help/geometry/136011-circle-involute-solving-y-any-given-x.html

function involute_intersect_angle(base_radius, radius) = sqrt( pow(radius/base_radius,2) - 1);



// Polar coord [angle, radius] to cartesian coord [x,y]

function polar_to_cartesian(polar) = [
	polar[1]*cos(polar[0]),
	polar[1]*sin(polar[0])
];


// Test Cases
//===============

module test_gears()
{
	gear(number_of_teeth=51,circular_pitch=200);
	translate([0, 50])gear(number_of_teeth=17,circular_pitch=200);
	translate([-50,0]) gear(number_of_teeth=17,diametral_pitch=1);
}

module demo_3d_gears()
{
	//double helical gear
	translate([50,0])
	{
	linear_extrude(height = 10, center = true, convexity = 10, twist = -45)
	 gear(number_of_teeth=17,diametral_pitch=1);
	translate([0,0,10])
        rotate([0,180,180/17])
        linear_extrude(height = 10, center = true, convexity = 10, twist = 45)
	 gear(number_of_teeth=17,diametral_pitch=1);
	}

	//spur gear
	translate([0,-50]) linear_extrude(height = 10, center = true, convexity = 10, twist = 0)
	 gear(number_of_teeth=17,diametral_pitch=1);

}

module test_involute_curve()
{
	for (i=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
	{
		translate(polar_to_cartesian([involute_intersect_angle( 0.1,i) , i ])) circle($fn=15, r=0.5);
	}
}
import py
import os.path
from openscad_utils import *


temppath = py.test.ensuretemp('MCAD')

def pytest_generate_tests(metafunc):
    if "modpath" in metafunc.funcargnames:
        args1 = []
        args2 = []
        for fpath, modnames in collect_test_modules().items():
            basename = os.path.splitext(os.path.split(str(fpath))[1])[0]
            if "modname" in metafunc.funcargnames:
                for modname in modnames:
                    args2.append([fpath, modname])
            else:
                args1.append(fpath)

        if "modname" in metafunc.funcargnames:
            metafunc.parametrize(["modpath", "modname"], args2)
        else:
            metafunc.parametrize("modpath", args1)

def test_module_compile(modname, modpath):
    tempname = modpath.basename + '-' + modname + '.scad'
    fpath = temppath.join(tempname)
    stlpath = temppath.join(tempname + ".stl")
    f = fpath.open('w')
    code = """
//generated testfile
use <%s>

%s();
""" % (modpath, modname)
    print(code)
    f.write(code)
    f.flush()
    output = call_openscad(path=fpath, stlpath=stlpath, timeout=60)
    print(output)
    assert output[0] is 0
    for s in ("warning", "error"):
        assert s not in output[2].strip().lower().decode("utf-8")
    assert len(stlpath.readlines()) > 2

def test_file_compile(modpath):
    stlpath = temppath.join(modpath.basename + "-test.stl")
    output = call_openscad(path=modpath, stlpath=stlpath)
    print(output)
    assert output[0] is 0
    for s in ("warning", "error"):
        assert s not in output[2].strip().lower().decode("utf-8")
    assert len(stlpath.readlines()) == 2
// Copyright 2010 D1plo1d

// This library is dual licensed under the GPL 3.0 and the GNU Lesser General Public License as per http://creativecommons.org/licenses/LGPL/2.1/ .

//testNutsAndBolts();

module SKIPtestNutsAndBolts()
{
	$fn = 360;
	translate([0,15])nutHole(3, proj=2);
	boltHole(3, length= 30, proj=2);
}

MM = "mm";
INCH = "inch"; //Not yet supported

//Based on: http://www.roymech.co.uk/Useful_Tables/Screws/Hex_Screws.htm
METRIC_NUT_AC_WIDTHS =
[
	-1, //0 index is not used but reduces computation
	-1,
	4.38,//m2
	6.40,//m3
	8.10,//m4
	9.20,//m5
	11.50,//m6
	-1,
	15.00,//m8
	-1,
	19.60,//m10
	-1,
	22.10,//m12
	-1,
	-1,
	-1,
	27.70,//m16
	-1,
	-1,
	-1,
	34.60,//m20
	-1,
	-1,
	-1,
	41.60,//m24
	-1,
	-1,
	-1,
	-1,
	-1,
	53.1,//m30
	-1,
	-1,
	-1,
	-1,
	-1,
	63.5//m36
];
METRIC_NUT_THICKNESS =
[
	-1, //0 index is not used but reduces computation
	-1,
	1.6,//m2
	2.40,//m3
	3.20,//m4
	4.00,//m5
	5.00,//m6
	-1,
	6.50,//m8
	-1,
	8.00,//m10
	-1,
	10.00,//m12
	-1,
	-1,
	-1,
	13.00,//m16
	-1,
	-1,
	-1,
	16.00//m20
	-1,
	-1,
	-1,
	19.00,//m24
	-1,
	-1,
	-1,
	-1,
	-1,
	24.00,//m30
	-1,
	-1,
	-1,
	-1,
	-1,
	29.00//m36
];

COARSE_THREAD_METRIC_BOLT_MAJOR_DIAMETERS =
[//based on max values
	-1, //0 index is not used but reduces computation
	-1,
	1.6,//m2
	2.98,//m3
	3.978,//m4
	4.976,//m5
	5.974,//m6
	-1,
	7.972,//m8
	-1,
	9.968,//m10
	-1,
	11.966,//m12
	-1,
	-1,
	-1,
	15.962,//m16
	-1,
	-1,
	-1,
	19.958,//m20
	-1,
	-1,
	-1,
	23.952,//m24
	-1,
	-1,
	-1,
	-1,
	-1,
	29.947,//m30
	-1,
	-1,
	-1,
	-1,
	-1,
	35.940//m36
];

// Deprecated, but kept around for people who use the wrong spelling.
COURSE_METRIC_BOLT_MAJOR_THREAD_DIAMETERS = COARSE_THREAD_METRIC_BOLT_MAJOR_DIAMETERS;

//Based on: http://www.roymech.co.uk/Useful_Tables/Screws/cap_screws.htm
METRIC_BOLT_CAP_DIAMETERS =
[
	-1, //0 index is not used but reduces computation
	-1,
	-1,
	5.50,//m3
	7.00,//m4
	8.50,//m5
	10.00,//m6
	-1,
	13.00,//m8
	-1,
	16.00,//m10
	-1,
	18.00,//m12
	-1,
	-1,
	-1,
	24.00,//m16
	-1,
	-1,
	-1,
	30.00//m20
	-1,
	-1,
	-1,
	36.00,//m24
	-1,
	-1,
	-1,
	-1,
	-1,
	45.00,//m30
	-1,
	-1,
	-1,
	-1,
	-1,
	54.00//m36
];

module nutHole(size, units=MM, tolerance = +0.0001, proj = -1)
{
	//takes a metric screw/nut size and looksup nut dimensions
	radius = METRIC_NUT_AC_WIDTHS[size]/2+tolerance;
	height = METRIC_NUT_THICKNESS[size]+tolerance;
	if (proj == -1)
	{
		cylinder(r= radius, h=height, $fn = 6, center=[0,0]);
	}
	if (proj == 1)
	{
		circle(r= radius, $fn = 6);
	}
	if (proj == 2)
	{
		translate([-radius/2, 0])
			square([radius*2, height]);
	}
}

module boltHole(size, units=MM, length, tolerance = +0.0001, proj = -1)
{
	radius = COARSE_THREAD_METRIC_BOLT_MAJOR_DIAMETERS[size]/2+tolerance;
	capHeight = size+tolerance;
	capRadius = METRIC_BOLT_CAP_DIAMETERS[size]/2+tolerance;

	if (proj == -1)
	{
	translate([0, 0, -capHeight])
		cylinder(r= capRadius, h=capHeight);
	cylinder(r = radius, h = length);
	}
	if (proj == 1)
	{
		circle(r = radius);
	}
	if (proj == 2)
	{
		translate([-capRadius/2, -capHeight])
			square([capRadius*2, capHeight]);
		square([radius*2, length]);
	}
}
*~
*.pyc
.pytest_cache/
__pycache__/
// MIT license

include <constants.scad>

function deg(angle) = 360*angle/TAU;

/*
 *  OpenSCAD Shapes Library (www.openscad.org)
 *  Copyright (C) 2010-2011  Giles Bathgate, Elmo Mäntynen
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License,
 *  LGPL version 2.1, or (at your option) any later version of the GPL.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
*/

// 2D regular shapes

module triangle(radius)
{
  o=radius/2;		//equivalent to radius*sin(30)
  a=radius*sqrt(3)/2;	//equivalent to radius*cos(30)
  polygon(points=[[-a,-o],[0,radius],[a,-o]],paths=[[0,1,2]]);
}

module reg_polygon(sides, radius) {
  echo("<font color='red'>
        DEPRECATED: function 'reg_polygon' is now deprecated
        please use 'regular_polygon' instead</font>");

     regular_polygon(sides, radius);
}

module regular_polygon(sides, radius)
{
  function dia(r) = sqrt(pow(r*2,2)/2);  //sqrt((r*2^2)/2) if only we had an exponention op
  if(sides<2) square([radius,0]);
  if(sides==3) triangle(radius);
  if(sides==4) square([dia(radius),dia(radius)],center=true);
  if(sides>4) {
    angles=[ for (i = [0:sides-1]) i*(360/sides) ];
    coords=[ for (th=angles) [radius*cos(th), radius*sin(th)] ];
    polygon(coords);
  }
}

module pentagon(radius)
{
  regular_polygon(5,radius);
}

module hexagon(radius, diameter, across_flats)
{
  r = across_flats ? across_flats/2/cos(30) : diameter ? diameter/2 : radius;
  regular_polygon(6,r);
}

module heptagon(radius)
{
  regular_polygon(7,radius);
}

module octagon(radius)
{
  regular_polygon(8,radius);
}

module nonagon(radius)
{
  regular_polygon(9,radius);
}

module decagon(radius)
{
  regular_polygon(10,radius);
}

module hendecagon(radius)
{
  regular_polygon(11,radius);
}

module dodecagon(radius)
{
  regular_polygon(12,radius);
}

module ring(inside_diameter, thickness){
  difference(){
    circle(r=(inside_diameter+thickness*2)/2);
    circle(r=inside_diameter/2);
  }
}

module ellipse(width, height) {
  scale([1, height/width, 1]) circle(r=width/2);
}

// The ratio of length and width is about 1.39 for a real egg
module egg_outline(width, length){
    translate([0, width/2, 0]) union(){
        rotate([0, 0, 180]) difference(){
            ellipse(width, 2*length-width);
            translate([-length/2, 0, 0]) square(length);
        }
        circle(r=width/2);
    }
}

//3D regular shapes

module cone(height, radius, center = false)
{
  cylinder(height, radius, 0, center);
}

module oval_prism(height, rx, ry, center = false)
{
  scale([1, rx/ry, 1]) cylinder(h=height, r=ry, center=center);
}

module oval_tube(height, rx, ry, wall, center = false)
{
  difference() {
    scale([1, ry/rx, 1]) cylinder(h=height, r=rx, center=center);
    translate([0,0,-height/2]) scale([(rx-wall)/rx, (ry-wall)/rx, 2]) cylinder(h=height, r=rx, center=center);
  }
}

module cylinder_tube(height, radius, wall, center = false)
{
    tubify(radius,wall)
    cylinder(h=height, r=radius, center=center);
}

//Tubifies any regular prism
module tubify(radius,wall)
{
  difference()
  {
    children(0);
    translate([0, 0, -0.1]) scale([(radius-wall)/radius, (radius-wall)/radius, 2]) children(0);
  }
}

module triangle_prism(height,radius)
{
  linear_extrude(height=height) triangle(radius);
}

module triangle_tube(height,radius,wall)
{
   tubify(radius,wall) triangle_prism(height,radius);
}

module pentagon_prism(height,radius)
{
  linear_extrude(height=height) pentagon(radius);
}

module pentagon_tube(height,radius,wall)
{
 tubify(radius,wall) pentagon_prism(height,radius);
}

module hexagon_prism(height, radius, across_flats)
{
  linear_extrude(height=height)
    hexagon(radius=radius, across_flats=across_flats);
}

module hexagon_tube(height,radius,wall)
{
 tubify(radius,wall) hexagon_prism(height,radius);
}

module heptagon_prism(height,radius)
{
  linear_extrude(height=height) heptagon(radius);
}

module heptagon_tube(height,radius,wall)
{
 tubify(radius,wall) heptagon_prism(height,radius);
}

module octagon_prism(height,radius)
{
  linear_extrude(height=height) octagon(radius);
}

module octagon_tube(height,radius,wall)
{
 tubify(radius,wall) octagon_prism(height,radius);
}

module nonagon_prism(height,radius)
{
  linear_extrude(height=height) nonagon(radius);
}

module decagon_prism(height,radius)
{
  linear_extrude(height=height) decagon(radius);
}

module hendecagon_prism(height,radius)
{
  linear_extrude(height=height) hendecagon(radius);
}

module dodecagon_prism(height,radius)
{
  linear_extrude(height=height) dodecagon(radius);
}

module torus(outerRadius, innerRadius)
{
  r=(outerRadius-innerRadius)/2;
  rotate_extrude() translate([innerRadius+r,0,0]) circle(r);
}

module torus2(r1, r2)
{
  rotate_extrude() translate([r1,0,0]) circle(r2);
}

module oval_torus(inner_radius, thickness=[0, 0])
{
  rotate_extrude() translate([inner_radius+thickness[0]/2,0,0]) ellipse(width=thickness[0], height=thickness[1]);
}


module triangle_pyramid(radius)
{
  o=radius/2;		//equivalent to radius*sin(30)
  a=radius*sqrt(3)/2;	//equivalent to radius*cos(30)
  polyhedron(points=[[-a,-o,-o],[a,-o,-o],[0,radius,-o],[0,0,radius]],triangles=[[0,1,2],[1,2,3],[0,1,3],[0,2,3]]);
}

module square_pyramid(base_x, base_y,height)
{
  w=base_x/2;
  h=base_y/2;
  polyhedron(points=[[-w,-h,0],[-w,h,0],[w,h,0],[w,-h,0],[0,0,height]],triangles=[[0,3,2,1], [0,1,4], [1,2,4], [2,3,4], [3,0,4]]);
}

module egg(width, length){
    rotate_extrude()
        difference(){
            egg_outline(width, length);
            translate([-length, 0, 0]) cube(2*length, center=true);
        }
}

// Tests:

test_square_pyramid(){square_pyramid(10, 20, 30);}
// ==============================================
// Miscellaneous profiles (aluminum etc)
// By Vitaly Mankevich / contraptor.org, (c) 2012
// LGPL 2.1
// ==============================================
//
// PROFILES (DIMENSIONLESS UNLESS SPECIFIED)
// -----------------------------------------
// profile_angle_equal(1, 1/8);
// profile_angle_unequal(1, 1/2, 1/16);
// profile_square_tube(1.5, 1/8);
// profile_rect_tube(1.5, 2, 1/8);
// profile_channel(1.5, 1, 1/8);
//
// profile_8020_fractional_1010(); // inches
// profile_misumi_metric_2020(); // millimeters
// profile_makerbeam();  // millimeters
//
// EXTRUDED PROFILES
// -----------------
// linear_extrude (height = 3.5) profile_square_tube(1.5, 1/8);
//

$fn = 24;

module profile_angle_equal(side, wall) {
	difference () {
		square (side);
		translate([wall, wall, 0]) square (side - wall);
	}
}

module profile_angle_unequal(side_x, side_y, wall) {
	difference () {
		square ([side_x, side_y]);
		translate ([wall, wall, 0]) square ([side_x - wall, side_y - wall]);
	}
}

module profile_square_tube(side, wall) {
	difference () {
		square (side, center = true);
		square (side-wall*2, center = true);
	}
}

module profile_rect_tube(side_x, side_y, wall) {
	difference () {
		square ([side_x, side_y], center = true);
		square ([side_x - wall*2, side_y - wall*2], center = true);
	}
}

module profile_channel(base, side, wall) {
	translate ([0, side/2, 0]) difference () {
		square ([base, side], center = true);
		translate ([0, wall/2, 0]) square ([base - wall*2, side - wall], center = true);
	}
}

module profile_tslot_generic (pitch, slot, lip, web, hole) {
	// pitch = side width, slot = slot width, lip = thickness of the lip, web = thickness of the web, core = side of the center square, hole = center hole diameter
	difference () {
		union() {
			difference () {
				square (pitch, center=true);
				square (pitch - lip*2, center=true);
				square ([pitch, slot], center=true);
				square ([slot, pitch], center=true);
			}
			rotate ([0, 0, 45]) square ([pitch*1.15, web], center=true);
			rotate ([0, 0, -45]) square ([pitch*1.15, web], center=true);
			square (core, center=true);
		}
		circle (hole/2, center = true);
	}
}

module profile_8020_fractional_1010 () {
	profile_tslot_generic (pitch = 1, slot = 0.26, lip = 0.1, web = 0.13, core = 0.45, hole = 0.28);
}

module profile_misumi_metric_2020 () {
	profile_tslot_generic (pitch = 20, slot = 5.2, lip = 2, web = 2.6, core = 9, hole = 5.6);
}

module profile_makerbeam () {
	profile_tslot_generic (pitch = 10, slot = 2.5, lip = 1, web = 2, core = 1, hole = 0);
}
// License: GNU LGPL 2.1 or later.
// © 2010 by Elmo Mäntynen

module local_scale(v, reference=[0, 0, 0]) {
    translate(-reference) scale(v) translate(reference) children();
}
/**
 * Servo outline library
 *
 * Authors:
 *   - Eero 'rambo' af Heurlin 2010-
 *
 * License: LGPL 2.1
 */

use <triangles.scad>

/**
 * TowerPro SG90 servo
 *
 * @param vector position The position vector
 * @param vector rotation The rotation vector
 * @param boolean screws If defined then "screws" will be added and when the module is differenced() from something if will have holes for the screws
 * @param boolean cables If defined then "cables" output will be added and when the module is differenced() from something if will have holes for the cables output
 * @param number axle_length If defined this will draw a red indicator for the main axle
 */
module towerprosg90(position=undef, rotation=undef, screws = 0, axle_length = 0, cables=0)
{
	translate(position) rotate(rotation) {
        difference(){
            union()
            {
                translate([-5.9,-11.8/2,0]) cube([22.5,11.8,22.7]);
                translate([0,0,22.7-0.1]){
                    cylinder(d=11.8,h=4+0.1);
                    hull(){
                        translate([8.8-5/2,0,0]) cylinder(d=5,h=4+0.1);
                        cylinder(d=5,h=4+0.1);
                    }
                    translate([0,0,4]) cylinder(d=4.6,h=3.2);
                }
                translate([-4.7-5.9,-11.8/2,15.9]) cube([22.5+4.7*2, 11.8, 2.5]); 
            }
            //screw holes
            translate([-2.3-5.9,0,15.9+1.25]) cylinder(d=2,h=5, center=true);
            translate([-2.3-5.9-2,0,15.9+1.25]) cube([3,1.3,5], center=true);
            translate([2.3+22.5-5.9,0,15.9+1.25]) cylinder(d=2,h=5, center=true);
            translate([2.3+22.5-5.9+2,0,15.9+1.25]) cube([3,1.3,5], center=true);
        }
        if (axle_length > 0) {
            color("red", 0.3) translate([0,0,29.9/2]) cylinder(r=1, h=29.9+axle_length, center=true);
        }
        if (cables > 0) color("red", 0.3) translate([-12.4,-1.8,4.5]) cube([10,3.6,1.2]);
        if(screws > 0) color("red", 0.3) {
            translate([-2.3-5.9,0,15.9+1.25]) cylinder(d=2,h=10, center=true);
            translate([2.3+22.5-5.9,0,15.9+1.25]) cylinder(d=2,h=10, center=true);
        }
    }
    
}

/**
 * Align DS420 digital servo
 *
 * @param vector position The position vector
 * @param vector rotation The rotation vector
 * @param boolean screws If defined then "screws" will be added and when the module is differenced() from something if will have holes for the screws
 * @param number axle_lenght If defined this will draw "backgound" indicator for the main axle
 */
module alignds420(position, rotation, screws = 0, axle_lenght = 0)
{
	translate(position)
	{
		rotate(rotation)
	    {
			union()
			{
				// Main axle
				translate([0,0,17])
				{
					cylinder(r=6, h=8, $fn=30);
					cylinder(r=2.5, h=10.5, $fn=20);
				}
				// Box and ears
				translate([-6,-6,0])
				{
					cube([12, 22.8,19.5], false);
					translate([0,-5, 17])
					{
						cube([12, 7, 2.5]);
					}
					translate([0, 20.8, 17])
					{
						cube([12, 7, 2.5]);
					}
				}
				if (screws > 0)
				{
					translate([0,(-10.2 + 1.8),11.5])
					{
						# cylinder(r=1.8/2, h=6, $fn=6);
					}
					translate([0,(21.0 - 1.8),11.5])
					{
						# cylinder(r=1.8/2, h=6, $fn=6);
					}

				}
				// The large slope
				translate([-6,0,19])
				{
					rotate([90,0,90])
					{
						triangle(4, 18, 12);
					}
				}

				/**
				 * This seems to get too complex fast
				// Small additional axes
				translate([0,6,17])
				{
					cylinder(r=2.5, h=6, $fn=10);
					cylinder(r=1.25, h=8, $fn=10);
				}
				// Small slope
				difference()
				{
					translate([-6,-6,19.0])
					{
						cube([12,6.5,4]);
					}
					translate([7,-7,24.0])
					{
						rotate([-90,0,90])
						{
				            triangle(3, 8, 14);
						}
					}

				}
				*/
				// So we render a cube instead of the small slope on a cube
				translate([-6,-6,19.0])
				{
					cube([12,6.5,4]);
				}
			}
			if (axle_lenght > 0)
			{
				% cylinder(r=0.9, h=axle_lenght, center=true, $fn=8);
			}
		}
	}
}

/**
 * Futaba S3003 servo
 *
 * @param vector position The position vector
 * @param vector rotation The rotation vector
 */
module futabas3003(position, rotation)
{
	translate(position)
	{
		rotate(rotation)
	    {
			union()
			{
				// Box and ears
				translate([0,0,0])
				{
					cube([20.1, 39.9, 36.1], false);
					translate([1.1, -7.6, 26.6])
					{
                        difference() {
						    cube([18, 7.6, 2.5]);
                            translate([4, 3.5, 0]) cylinder(100, 2);
                            translate([14, 3.5, 0]) cylinder(100, 2);
                        }
					}

					translate([1.1, 39.9, 26.6])
					{
                        difference() {
                            cube([18, 7.6, 2.5]);
                            translate([4, 4.5, 0]) cylinder(100, 2);
                            translate([14, 4.5, 0]) cylinder(100, 2);
                        }
                    }
				}

				// Main axle
				translate([10, 30, 36.1])
				{
					cylinder(r=6, h=0.4, $fn=30);
					cylinder(r=2.5, h=4.9, $fn=20);
				}
			}
		}
	}
}

// Tests:
module test_alignds420(){alignds420(screws=1);}
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
// Copyright 2011 Elmo Mäntynen
// LGPL 2.1

// Give a list of 4+4 points (check order) to form an 8 point polyhedron 
module connect_squares(points){
    polyhedron(points=points,
               triangles=[[0,1,2], [3,0,2], [7,6,5], [7,5,4], // Given polygons
                          [0,4,1], [4,5,1], [1,5,2], [2,5,6],  // Connecting
                          [2,6,3], [3,6,7], [3,4,0], [3,7,4]]);// sides
}
/*
 * A nema standard stepper motor module.
 * 
 * Originally by Hans Häggström, 2010.
 * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later
 */

include <units.scad>
include <materials.scad>


// Demo, uncomment to show:
//nema_demo();

module nema_demo(){
    for (size = [NemaShort, NemaMedium, NemaLong]) {  
      translate([-100,size*100,0]) motor(Nema34, size, dualAxis=true);
      translate([0,size*100,0])    motor(Nema23, size, dualAxis=true);
      translate([100,size*100,0])  motor(Nema17, size, dualAxis=true);
      translate([200,size*100,0])  motor(Nema14, size, dualAxis=true);
      translate([300,size*100,0])  motor(Nema11, size, dualAxis=true);
      translate([400,size*100,0])  motor(Nema08, size, dualAxis=true);
    }
}


// Parameters: 
NemaModel = 0;
NemaLengthShort = 1;
NemaLengthMedium = 2;
NemaLengthLong = 3;
NemaSideSize = 4;
NemaDistanceBetweenMountingHoles = 5;
NemaMountingHoleDiameter = 6;
NemaMountingHoleDepth = 7;
NemaMountingHoleLip = 8;
NemaMountingHoleCutoutRadius = 9;
NemaEdgeRoundingRadius = 10;
NemaRoundExtrusionDiameter = 11;
NemaRoundExtrusionHeight = 12;
NemaAxleDiameter = 13;
NemaFrontAxleLength = 14;
NemaBackAxleLength = 15;
NemaAxleFlatDepth = 16;
NemaAxleFlatLengthFront = 17;
NemaAxleFlatLengthBack = 18;

NemaA = 1;
NemaB = 2;
NemaC = 3;

NemaShort = NemaA;
NemaMedium = NemaB;
NemaLong = NemaC;

// TODO: The small motors seem to be a bit too long, I picked the size specs from all over the place, is there some canonical reference?
Nema08 = [
                [NemaModel, 8],
                [NemaLengthShort, 33*mm],
                [NemaLengthMedium, 43*mm],
                [NemaLengthLong, 43*mm],
                [NemaSideSize, 20*mm], 
                [NemaDistanceBetweenMountingHoles, 15.4*mm], 
                [NemaMountingHoleDiameter, 2*mm], 
                [NemaMountingHoleDepth, 1.75*mm], 
                [NemaMountingHoleLip, -1*mm], 
                [NemaMountingHoleCutoutRadius, 0*mm], 
                [NemaEdgeRoundingRadius, 2*mm], 
                [NemaRoundExtrusionDiameter, 16*mm], 
                [NemaRoundExtrusionHeight, 1.5*mm], 
                [NemaAxleDiameter, 4*mm], 
                [NemaFrontAxleLength, 13.5*mm], 
                [NemaBackAxleLength, 9.9*mm],
                [NemaAxleFlatDepth, -1*mm],
                [NemaAxleFlatLengthFront, 0*mm],
                [NemaAxleFlatLengthBack, 0*mm]
         ];

Nema11 = [
                [NemaModel, 11],
                [NemaLengthShort, 32*mm],
                [NemaLengthMedium, 40*mm],
                [NemaLengthLong, 52*mm],
                [NemaSideSize, 28*mm], 
                [NemaDistanceBetweenMountingHoles, 23*mm], 
                [NemaMountingHoleDiameter, 2.5*mm], 
                [NemaMountingHoleDepth, 2*mm], 
                [NemaMountingHoleLip, -1*mm], 
                [NemaMountingHoleCutoutRadius, 0*mm], 
                [NemaEdgeRoundingRadius, 2.5*mm], 
                [NemaRoundExtrusionDiameter, 22*mm], 
                [NemaRoundExtrusionHeight, 1.8*mm], 
                [NemaAxleDiameter, 5*mm], 
                [NemaFrontAxleLength, 13.7*mm], 
                [NemaBackAxleLength, 10*mm],
                [NemaAxleFlatDepth, 0.5*mm],
                [NemaAxleFlatLengthFront, 10*mm],
                [NemaAxleFlatLengthBack, 9*mm]
         ];

Nema14 = [
                [NemaModel, 14],
                [NemaLengthShort, 26*mm], 
                [NemaLengthMedium, 28*mm], 
                [NemaLengthLong, 34*mm], 
                [NemaSideSize, 35.3*mm], 
                [NemaDistanceBetweenMountingHoles, 26*mm], 
                [NemaMountingHoleDiameter, 3*mm], 
                [NemaMountingHoleDepth, 3.5*mm], 
                [NemaMountingHoleLip, -1*mm], 
                [NemaMountingHoleCutoutRadius, 0*mm], 
                [NemaEdgeRoundingRadius, 5*mm], 
                [NemaRoundExtrusionDiameter, 22*mm], 
                [NemaRoundExtrusionHeight, 1.9*mm], 
                [NemaAxleDiameter, 5*mm], 
                [NemaFrontAxleLength, 18*mm], 
                [NemaBackAxleLength, 10*mm],
                [NemaAxleFlatDepth, 0.5*mm],
                [NemaAxleFlatLengthFront, 15*mm],
                [NemaAxleFlatLengthBack, 9*mm]
         ];

Nema17 = [
                [NemaModel, 17],
                [NemaLengthShort, 33*mm],
                [NemaLengthMedium, 39*mm],
                [NemaLengthLong, 47*mm],
                [NemaSideSize, 42.20*mm], 
                [NemaDistanceBetweenMountingHoles, 31.04*mm], 
                [NemaMountingHoleDiameter, 4*mm], 
                [NemaMountingHoleDepth, 4.5*mm], 
                [NemaMountingHoleLip, -1*mm], 
                [NemaMountingHoleCutoutRadius, 0*mm], 
                [NemaEdgeRoundingRadius, 7*mm], 
                [NemaRoundExtrusionDiameter, 22*mm], 
                [NemaRoundExtrusionHeight, 1.9*mm], 
                [NemaAxleDiameter, 5*mm], 
                [NemaFrontAxleLength, 18*mm], 
                [NemaBackAxleLength, 15*mm],
                [NemaAxleFlatDepth, 0.5*mm],
                [NemaAxleFlatLengthFront, 15*mm],
                [NemaAxleFlatLengthBack, 14*mm]
         ];

Nema23 = [
                [NemaModel, 23],
                [NemaLengthShort, 39*mm],
                [NemaLengthMedium, 54*mm],
                [NemaLengthLong, 76*mm],
                [NemaSideSize, 56.4*mm], 
                [NemaDistanceBetweenMountingHoles, 47.14*mm], 
                [NemaMountingHoleDiameter, 4.75*mm], 
                [NemaMountingHoleDepth, 5*mm], 
                [NemaMountingHoleLip, 4.95*mm], 
                [NemaMountingHoleCutoutRadius, 9.5*mm], 
                [NemaEdgeRoundingRadius, 2.5*mm], 
                [NemaRoundExtrusionDiameter, 38.10*mm], 
                [NemaRoundExtrusionHeight, 1.52*mm], 
                [NemaAxleDiameter, 6.36*mm], 
                [NemaFrontAxleLength, 18.80*mm], 
                [NemaBackAxleLength, 15.60*mm],
                [NemaAxleFlatDepth, 0.5*mm],
                [NemaAxleFlatLengthFront, 16*mm],
                [NemaAxleFlatLengthBack, 14*mm]
         ];

Nema34 = [
                [NemaModel, 34],
                [NemaLengthShort, 66*mm],
                [NemaLengthMedium, 96*mm],
                [NemaLengthLong, 126*mm],
                [NemaSideSize, 85*mm], 
                [NemaDistanceBetweenMountingHoles, 69.58*mm], 
                [NemaMountingHoleDiameter, 6.5*mm], 
                [NemaMountingHoleDepth, 5.5*mm], 
                [NemaMountingHoleLip, 5*mm], 
                [NemaMountingHoleCutoutRadius, 17*mm], 
                [NemaEdgeRoundingRadius, 3*mm], 
                [NemaRoundExtrusionDiameter, 73.03*mm], 
                [NemaRoundExtrusionHeight, 1.9*mm], 
                [NemaAxleDiameter, 0.5*inch], 
                [NemaFrontAxleLength, 37*mm], 
                [NemaBackAxleLength, 34*mm],
                [NemaAxleFlatDepth, 1.20*mm],
                [NemaAxleFlatLengthFront, 25*mm],
                [NemaAxleFlatLengthBack, 25*mm]
         ];



function motorWidth(model=Nema23) = lookup(NemaSideSize, model);
function motorLength(model=Nema23, size=NemaMedium) = lookup(size, model);


module motor(model=Nema23, size=NemaMedium, dualAxis=false, pos=[0,0,0], orientation = [0,0,0]) {

  length = lookup(size, model);

  echo(str("  Motor: Nema",lookup(NemaModel, model),", length= ",length,"mm, dual axis=",dualAxis));

  stepperBlack    = BlackPaint;
  stepperAluminum = Aluminum;

  side = lookup(NemaSideSize, model);

  cutR = lookup(NemaMountingHoleCutoutRadius, model);
  lip = lookup(NemaMountingHoleLip, model);
  holeDepth = lookup(NemaMountingHoleDepth, model);

  axleLengthFront = lookup(NemaFrontAxleLength, model);
  axleLengthBack = lookup(NemaBackAxleLength, model);
  axleRadius = lookup(NemaAxleDiameter, model) * 0.5;

  extrSize = lookup(NemaRoundExtrusionHeight, model);
  extrRad = lookup(NemaRoundExtrusionDiameter, model) * 0.5;

  holeDist = lookup(NemaDistanceBetweenMountingHoles, model) * 0.5;
  holeRadius = lookup(NemaMountingHoleDiameter, model) * 0.5;

  mid = side / 2;

  roundR = lookup(NemaEdgeRoundingRadius, model);

  axleFlatDepth = lookup(NemaAxleFlatDepth, model);
  axleFlatLengthFront = lookup(NemaAxleFlatLengthFront, model);
  axleFlatLengthBack = lookup(NemaAxleFlatLengthBack, model);

  color(stepperBlack){
    translate(pos) rotate(orientation) {
      translate([-mid, -mid, 0]) 
        difference() {          
          cube(size=[side, side, length + extrSize]);
 
          // Corner cutouts
          if (lip > 0) {
            translate([0,    0,    lip]) cylinder(h=length, r=cutR);
            translate([side, 0,    lip]) cylinder(h=length, r=cutR);
            translate([0,    side, lip]) cylinder(h=length, r=cutR);
            translate([side, side, lip]) cylinder(h=length, r=cutR);

          }

          // Rounded edges
          if (roundR > 0) {
                translate([mid+mid, mid+mid, length/2])
                  rotate([0,0,45])
                    cube(size=[roundR, roundR*2, 4+length + extrSize+2], center=true);
                translate([mid-(mid), mid+(mid), length/2])
                  rotate([0,0,45])
                    cube(size=[roundR*2, roundR, 4+length + extrSize+2], center=true);
                translate([mid+mid, mid-mid, length/2])
                  rotate([0,0,45])
                    cube(size=[roundR*2, roundR, 4+length + extrSize+2], center=true);
                translate([mid-mid, mid-mid, length/2])
                  rotate([0,0,45])
                    cube(size=[roundR, roundR*2, 4+length + extrSize+2], center=true);

          }

          // Bolt holes
          color(stepperAluminum, $fs=holeRadius/8) {
            translate([mid+holeDist,mid+holeDist,-1*mm]) cylinder(h=holeDepth+1*mm+extrSize, r=holeRadius);
            translate([mid-holeDist,mid+holeDist,-1*mm]) cylinder(h=holeDepth+1*mm+extrSize, r=holeRadius);
            translate([mid+holeDist,mid-holeDist,-1*mm]) cylinder(h=holeDepth+1*mm+extrSize, r=holeRadius);
            translate([mid-holeDist,mid-holeDist,-1*mm]) cylinder(h=holeDepth+1*mm+extrSize, r=holeRadius);

          } 

          // Grinded flat
          color(stepperAluminum) {
            difference() {
              translate([-1*mm, -1*mm, -1*mm])
                cube(size=[side+2*mm, side+2*mm, extrSize + 1*mm]);
              translate([side/2, side/2, -1*mm])
                cylinder(h=extrSize + 1*mm, r=extrRad);
            }
          }

        }

      // Axle
      translate([0, 0, extrSize-axleLengthFront]) color(stepperAluminum) 
        difference() {
                     
          cylinder(h=axleLengthFront + 1*mm , r=axleRadius, $fs=axleRadius/10);

          // Flat
          if (axleFlatDepth > 0)
            translate([axleRadius - axleFlatDepth,-5*mm,-extrSize*mm -(axleLengthFront-axleFlatLengthFront)] ) cube(size=[5*mm, 10*mm, axleLengthFront]);
        }

        if (dualAxis) {
          translate([0, 0, length+extrSize]) color(stepperAluminum) 
            difference() {
                     
              cylinder(h=axleLengthBack + 0*mm, r=axleRadius, $fs=axleRadius/10);

              // Flat
              if (axleFlatDepth > 0)
                translate([axleRadius - axleFlatDepth,-5*mm,(axleLengthBack-axleFlatLengthBack)]) cube(size=[5*mm, 10*mm, axleLengthBack]);
          }

        }

    }
  }
}

module roundedBox(size, edgeRadius) {
    cube(size);

}

/*
 * Utility functions.
 *
 * Originally by Hans Häggström, 2010.
 * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later
 */

include <units.scad>

function distance(a, b) = sqrt( (a[0] - b[0])*(a[0] - b[0]) +
                                (a[1] - b[1])*(a[1] - b[1]) +
                                (a[2] - b[2])*(a[2] - b[2]) );

function length2(a) = sqrt( a[0]*a[0] + a[1]*a[1] );

function normalized(a) = a / (max(distance([0,0,0], a), 0.00001));

function normalized_axis(a) = a == "x" ? [1, 0, 0]:
                   a == "y" ? [0, 1, 0]:
                   a == "z" ? [0, 0, 1]: normalized(a);

function angleOfNormalizedVector(n) = [0, -atan2(n[2], length2([n[0], n[1]])), atan2(n[1], n[0]) ];

function angle(v) = angleOfNormalizedVector(normalized(v));

function angleBetweenTwoPoints(a, b) = angle(normalized(b-a));


CENTER = 0;
LEFT = -0.5;
RIGHT = 0.5;
TOP = 0.5;
BOTTOM = -0.5;

FlatCap =0;
ExtendedCap =0.5;
CutCap =-0.5;


module fromTo(from=[0,0,0], to=[1*m,0,0], size=[1*cm, 1*cm], align=[CENTER, CENTER], material=[0.5, 0.5, 0.5], name="", endExtras=[0,0], endCaps=[FlatCap, FlatCap], rotation=[0,0,0], printString=true) {

  angle = angleBetweenTwoPoints(from, to);
  length = distance(from, to) + endCaps[0]*size[0] + endCaps[1]*size[0] + endExtras[0] + endExtras[1];

  if (length > 0) {
    if (printString) echo(str("  " ,name, " ", size[0], "mm x ", size[1], "mm, length ",length,"mm"));

    color(material)
      translate(from)
        rotate(angle)
          translate( [ -endCaps[0]*size[0] - endExtras[0], size[0]*(-0.5-align[0]), size[1]*(-0.5+align[1]) ] )
            rotate(rotation)
              scale([length, size[0], size[1]]) children();
  }
}

module part(name) {
  echo("");
  echo(str(name, ":"));
}
// Parametric Involute Bevel and Spur Gears by GregFrost
// It is licensed under the Creative Commons - GNU LGPL 2.1 license.
// © 2010 by GregFrost, thingiverse.com/Amp
// http://www.thingiverse.com/thing:3575 and http://www.thingiverse.com/thing:3752

// Simple Test:
//gear (circular_pitch=700,
//	gear_thickness = 12,
//	rim_thickness = 15,
//	hub_thickness = 17,
//	circles=8);

//Complex Spur Gear Test:
//test_gears ();

// Meshing Double Helix:
//test_meshing_double_helix ();

module test_meshing_double_helix(){
    meshing_double_helix ();
}

// Demonstrate the backlash option for Spur gears.
//test_backlash ();

// Demonstrate how to make meshing bevel gears.
//test_bevel_gear_pair();

module test_bevel_gear_pair(){
    bevel_gear_pair ();
}

module test_bevel_gear(){bevel_gear();}

//bevel_gear();

pi=3.1415926535897932384626433832795;

//==================================================
// Bevel Gears:
// Two gears with the same cone distance, circular pitch (measured at the cone distance)
// and pressure angle will mesh.

module bevel_gear_pair (
	gear1_teeth = 41,
	gear2_teeth = 7,
	axis_angle = 90,
	outside_circular_pitch=1000)
{
	outside_pitch_radius1 = gear1_teeth * outside_circular_pitch / 360;
	outside_pitch_radius2 = gear2_teeth * outside_circular_pitch / 360;
	pitch_apex1=outside_pitch_radius2 * sin (axis_angle) +
		(outside_pitch_radius2 * cos (axis_angle) + outside_pitch_radius1) / tan (axis_angle);
	cone_distance = sqrt (pow (pitch_apex1, 2) + pow (outside_pitch_radius1, 2));
	pitch_apex2 = sqrt (pow (cone_distance, 2) - pow (outside_pitch_radius2, 2));
	echo ("cone_distance", cone_distance);
	pitch_angle1 = asin (outside_pitch_radius1 / cone_distance);
	pitch_angle2 = asin (outside_pitch_radius2 / cone_distance);
	echo ("pitch_angle1, pitch_angle2", pitch_angle1, pitch_angle2);
	echo ("pitch_angle1 + pitch_angle2", pitch_angle1 + pitch_angle2);

	rotate([0,0,90])
	translate ([0,0,pitch_apex1+20])
	{
		translate([0,0,-pitch_apex1])
		bevel_gear (
			number_of_teeth=gear1_teeth,
			cone_distance=cone_distance,
			pressure_angle=30,
			outside_circular_pitch=outside_circular_pitch);

		rotate([0,-(pitch_angle1+pitch_angle2),0])
		translate([0,0,-pitch_apex2])
		bevel_gear (
			number_of_teeth=gear2_teeth,
			cone_distance=cone_distance,
			pressure_angle=30,
			outside_circular_pitch=outside_circular_pitch);
	}
}

//Bevel Gear Finishing Options:
bevel_gear_flat = 0;
bevel_gear_back_cone = 1;

module bevel_gear (
	number_of_teeth=11,
	cone_distance=100,
	face_width=20,
	outside_circular_pitch=1000,
	pressure_angle=30,
	clearance = 0.2,
	bore_diameter=5,
	gear_thickness = 15,
	backlash = 0,
	involute_facets=0,
	finish = -1)
{
	echo ("bevel_gear",
		"teeth", number_of_teeth,
		"cone distance", cone_distance,
		face_width,
		outside_circular_pitch,
		pressure_angle,
		clearance,
		bore_diameter,
		involute_facets,
		finish);

	// Pitch diameter: Diameter of pitch circle at the fat end of the gear.
	outside_pitch_diameter  =  number_of_teeth * outside_circular_pitch / 180;
	outside_pitch_radius = outside_pitch_diameter / 2;

	// The height of the pitch apex.
	pitch_apex = sqrt (pow (cone_distance, 2) - pow (outside_pitch_radius, 2));
	pitch_angle = asin (outside_pitch_radius/cone_distance);

	echo ("Num Teeth:", number_of_teeth, " Pitch Angle:", pitch_angle);

	finish = (finish != -1) ? finish : (pitch_angle < 45) ? bevel_gear_flat : bevel_gear_back_cone;

	apex_to_apex=cone_distance / cos (pitch_angle);
	back_cone_radius = apex_to_apex * sin (pitch_angle);

	// Calculate and display the pitch angle. This is needed to determine the angle to mount two meshing cone gears.

	// Base Circle for forming the involute teeth shape.
	base_radius = back_cone_radius * cos (pressure_angle);

	// Diametrial pitch: Number of teeth per unit length.
	pitch_diametrial = number_of_teeth / outside_pitch_diameter;

	// Addendum: Radial distance from pitch circle to outside circle.
	addendum = 1 / pitch_diametrial;
	// Outer Circle
	outer_radius = back_cone_radius + addendum;

	// Dedendum: Radial distance from pitch circle to root diameter
	dedendum = addendum + clearance;
	dedendum_angle = atan (dedendum / cone_distance);
	root_angle = pitch_angle - dedendum_angle;

	root_cone_full_radius = tan (root_angle)*apex_to_apex;
	back_cone_full_radius=apex_to_apex / tan (pitch_angle);

	back_cone_end_radius =
		outside_pitch_radius -
		dedendum * cos (pitch_angle) -
		gear_thickness / tan (pitch_angle);
	back_cone_descent = dedendum * sin (pitch_angle) + gear_thickness;

	// Root diameter: Diameter of bottom of tooth spaces.
	root_radius = back_cone_radius - dedendum;

	half_tooth_thickness = outside_pitch_radius * sin (360 / (4 * number_of_teeth)) - backlash / 4;
	half_thick_angle = asin (half_tooth_thickness / back_cone_radius);

	face_cone_height = apex_to_apex-face_width / cos (pitch_angle);
	face_cone_full_radius = face_cone_height / tan (pitch_angle);
	face_cone_descent = dedendum * sin (pitch_angle);
	face_cone_end_radius =
		outside_pitch_radius -
		face_width / sin (pitch_angle) -
		face_cone_descent / tan (pitch_angle);

	// For the bevel_gear_flat finish option, calculate the height of a cube to select the portion of the gear that includes the full pitch face.
	bevel_gear_flat_height = pitch_apex - (cone_distance - face_width) * cos (pitch_angle);

//	translate([0,0,-pitch_apex])
	difference ()
	{
		intersection ()
		{
			union()
			{
				rotate (half_thick_angle)
				translate ([0,0,pitch_apex-apex_to_apex])
				cylinder ($fn=number_of_teeth*2, r1=root_cone_full_radius,r2=0,h=apex_to_apex);
				for (i = [1:number_of_teeth])
//				for (i = [1:1])
				{
					rotate ([0,0,i*360/number_of_teeth])
					{
						involute_bevel_gear_tooth (
							back_cone_radius = back_cone_radius,
							root_radius = root_radius,
							base_radius = base_radius,
							outer_radius = outer_radius,
							pitch_apex = pitch_apex,
							cone_distance = cone_distance,
							half_thick_angle = half_thick_angle,
							involute_facets = involute_facets);
					}
				}
			}

			if (finish == bevel_gear_back_cone)
			{
				translate ([0,0,-back_cone_descent])
				cylinder (
					$fn=number_of_teeth*2,
					r1=back_cone_end_radius,
					r2=back_cone_full_radius*2,
					h=apex_to_apex + back_cone_descent);
			}
			else
			{
				translate ([-1.5*outside_pitch_radius,-1.5*outside_pitch_radius,0])
				cube ([3*outside_pitch_radius,
					3*outside_pitch_radius,
					bevel_gear_flat_height]);
			}
		}

		if (finish == bevel_gear_back_cone)
		{
			translate ([0,0,-face_cone_descent])
			cylinder (
				r1=face_cone_end_radius,
				r2=face_cone_full_radius * 2,
				h=face_cone_height + face_cone_descent+pitch_apex);
		}

		translate ([0,0,pitch_apex - apex_to_apex])
		cylinder (r=bore_diameter/2,h=apex_to_apex);
	}
}

module involute_bevel_gear_tooth (
	back_cone_radius,
	root_radius,
	base_radius,
	outer_radius,
	pitch_apex,
	cone_distance,
	half_thick_angle,
	involute_facets)
{
//	echo ("involute_bevel_gear_tooth",
//		back_cone_radius,
//		root_radius,
//		base_radius,
//		outer_radius,
//		pitch_apex,
//		cone_distance,
//		half_thick_angle);

	min_radius = max (base_radius*2,root_radius*2);

	pitch_point =
		involute (
			base_radius*2,
			involute_intersect_angle (base_radius*2, back_cone_radius*2));
	pitch_angle = atan2 (pitch_point[1], pitch_point[0]);
	centre_angle = pitch_angle + half_thick_angle;

	start_angle = involute_intersect_angle (base_radius*2, min_radius);
	stop_angle = involute_intersect_angle (base_radius*2, outer_radius*2);

	res=(involute_facets!=0)?involute_facets:($fn==0)?5:$fn/4;

	translate ([0,0,pitch_apex])
	rotate ([0,-atan(back_cone_radius/cone_distance),0])
	translate ([-back_cone_radius*2,0,-cone_distance*2])
	union ()
	{
		for (i=[1:res])
		{
			assign (
				point1=
					involute (base_radius*2,start_angle+(stop_angle - start_angle)*(i-1)/res),
				point2=
					involute (base_radius*2,start_angle+(stop_angle - start_angle)*(i)/res))
			{
				assign (
					side1_point1 = rotate_point (centre_angle, point1),
					side1_point2 = rotate_point (centre_angle, point2),
					side2_point1 = mirror_point (rotate_point (centre_angle, point1)),
					side2_point2 = mirror_point (rotate_point (centre_angle, point2)))
				{
					polyhedron (
						points=[
							[back_cone_radius*2+0.1,0,cone_distance*2],
							[side1_point1[0],side1_point1[1],0],
							[side1_point2[0],side1_point2[1],0],
							[side2_point2[0],side2_point2[1],0],
							[side2_point1[0],side2_point1[1],0],
							[0.1,0,0]],
						triangles=[[0,2,1],[0,3,2],[0,4,3],[0,1,5],[1,2,5],[2,3,5],[3,4,5],[0,5,4]]);
				}
			}
		}
	}
}

module gear (
	number_of_teeth=15,
	circular_pitch=undef, diametral_pitch=undef,
	pressure_angle=28,
	clearance = undef,
	gear_thickness=5,
	rim_thickness=undef,
	rim_width=undef,
	hub_thickness=undef,
	hub_diameter=undef,
	bore_diameter=undef,
	circles=0,
	backlash=0,
	twist=0,
	involute_facets=0,
	flat=false)
{
	// Check for undefined circular pitch (happens when neither circular_pitch or diametral_pitch are specified)
	if (circular_pitch==undef)
		echo("MCAD ERROR: gear module needs either a diametral_pitch or circular_pitch");

	//Convert diametrial pitch to our native circular pitch
	circular_pitch = (circular_pitch!=undef?circular_pitch:pi/diametral_pitch);

	// Calculate default clearance if not specified
	clearance = (clearance!=undef?clearance:0.25 * circular_pitch / pi);

	// Pitch diameter: Diameter of pitch circle.
	pitch_diameter  =  number_of_teeth * circular_pitch / pi;
	pitch_radius = pitch_diameter/2;
	echo (str("Teeth: ", number_of_teeth, ", Pitch Radius: ", pitch_radius, ", Clearance: ", clearance));

	// Base Circle
	base_radius = pitch_radius*cos(pressure_angle);

	// Diametrial pitch: Number of teeth per unit length.
	pitch_diametrial = number_of_teeth / pitch_diameter;

	// Addendum: Radial distance from pitch circle to outside circle.
	addendum = 1/pitch_diametrial;

	//Outer Circle
	outer_radius = pitch_radius+addendum;

	// Dedendum: Radial distance from pitch circle to root diameter
	dedendum = addendum + clearance;

	// Root diameter: Diameter of bottom of tooth spaces.
	root_radius = pitch_radius-dedendum;
	backlash_angle = backlash / pitch_radius * 180 / pi;
	half_thick_angle = (360 / number_of_teeth - backlash_angle) / 4;

	// Variables controlling the rim.
	rim_thickness = (rim_thickness!=undef?(rim_thickness!=0?rim_thickness:gear_thickness):gear_thickness * 1.5);
	rim_width = (rim_width!=undef?rim_width:root_radius * .1);
	rim_radius = root_radius - rim_width;

	// Variables controlling the hub_diameter
	hub_thickness = (hub_thickness!=undef?(hub_thickness!=0?hub_thickness:gear_thickness):gear_thickness * 2);
	hub_diameter = (hub_diameter!=undef?hub_diameter:root_radius * .3);

	// Variables controlling the bore
	bore_diameter = (bore_diameter!=undef?bore_diameter:root_radius * .1);

	// Variables controlling the circular holes in the gear.
	circle_orbit_diameter=hub_diameter/2+rim_radius;
	circle_orbit_curcumference=pi*circle_orbit_diameter;

	// Limit the circle size to 90% of the gear face.
	circle_diameter=
		min (
			0.70*circle_orbit_curcumference/circles,
			(rim_radius-hub_diameter/2)*0.9);

	difference()
	{
		union ()
		{
			difference ()
			{
				linear_extrude_flat_option(flat=flat, height=rim_thickness, convexity=10, twist=twist)
				gear_shape (
					number_of_teeth,
					pitch_radius = pitch_radius,
					root_radius = root_radius,
					base_radius = base_radius,
					outer_radius = outer_radius,
					half_thick_angle = half_thick_angle,
					involute_facets=involute_facets);

				if (flat == false && gear_thickness < rim_thickness)
					translate ([0,0,gear_thickness])
					cylinder (r=rim_radius,h=rim_thickness-gear_thickness+1);
			}
			if (gear_thickness > rim_thickness)
				linear_extrude_flat_option(flat=flat, height=gear_thickness)
				circle (r=rim_radius);
			if (flat == false && hub_thickness > gear_thickness)
				translate ([0,0,gear_thickness])
				linear_extrude_flat_option(flat=flat, height=hub_thickness-gear_thickness)
				circle (r=hub_diameter/2);
		}
		translate ([0,0,-1])
		linear_extrude_flat_option(flat =flat, height=2+max(rim_thickness,hub_thickness,gear_thickness))
		circle (r=bore_diameter/2);
		if (circles>0)
		{
			for(i=[0:circles-1])
				rotate([0,0,i*360/circles])
				translate([circle_orbit_diameter/2,0,-1])
				linear_extrude_flat_option(flat =flat, height=max(gear_thickness,rim_thickness)+3)
				circle(r=circle_diameter/2);
		}
	}
}

module rack(
		number_of_teeth=15,
		circular_pitch=false, diametral_pitch=false,
		pressure_angle=28,
		clearance=0.2,
		rim_thickness=8,
		rim_width=5,
		flat=false)
{

	if (circular_pitch==false && diametral_pitch==false)
		echo("MCAD ERROR: gear module needs either a diametral_pitch or circular_pitch");

	//Convert diametrial pitch to our native circular pitch
	circular_pitch = (circular_pitch!=false?circular_pitch:180/diametral_pitch);
	pitch = circular_pitch / 180 * PI;

	addendum = circular_pitch / 180;
	dedendum = addendum + clearance;
	pitch_slope = tan(pressure_angle);

	linear_extrude_flat_option(flat=flat, height=rim_thickness)
		union()
		{
			translate([0,-dedendum-rim_width/2])
				square([number_of_teeth*pitch, rim_width],center=true);

			p1 = pitch / 4 + pitch_slope * dedendum;
			p2 = pitch / 4 - pitch_slope * addendum;
			for(i=[1:number_of_teeth])
				translate([pitch*(i-number_of_teeth/2-0.5),0])
					polygon(points=[
							[-p1,-dedendum],
							[p1,-dedendum],
							[p2,addendum],
							[-p2,addendum]
					]);
		}
}

module linear_extrude_flat_option(flat =false, height = 10, center = false, convexity = 2, twist = 0)
{
	if(flat==false)
	{
		linear_extrude(height = height, center = center, convexity = convexity, twist= twist) children(0);
	}
	else
	{
		children(0);
	}

}

module gear_shape (
	number_of_teeth,
	pitch_radius,
	root_radius,
	base_radius,
	outer_radius,
	half_thick_angle,
	involute_facets)
{
	union()
	{
		rotate (half_thick_angle) circle ($fn=number_of_teeth*2, r=root_radius);

		for (i = [1:number_of_teeth])
		{
			rotate ([0,0,i*360/number_of_teeth])
			{
				involute_gear_tooth (
					pitch_radius = pitch_radius,
					root_radius = root_radius,
					base_radius = base_radius,
					outer_radius = outer_radius,
					half_thick_angle = half_thick_angle,
					involute_facets=involute_facets);
			}
		}
	}
}

module involute_gear_tooth (
	pitch_radius,
	root_radius,
	base_radius,
	outer_radius,
	half_thick_angle,
	involute_facets)
{
	min_radius = max (base_radius,root_radius);

	pitch_point = involute (base_radius, involute_intersect_angle (base_radius, pitch_radius));
	pitch_angle = atan2 (pitch_point[1], pitch_point[0]);
	centre_angle = pitch_angle + half_thick_angle;

	start_angle = involute_intersect_angle (base_radius, min_radius);
	stop_angle = involute_intersect_angle (base_radius, outer_radius);

	res=(involute_facets!=0)?involute_facets:($fn==0)?5:$fn/4;

	union ()
	{
		for (i=[1:res]) {
			point1=involute (base_radius,start_angle+(stop_angle - start_angle)*(i-1)/res);
			point2=involute (base_radius,start_angle+(stop_angle - start_angle)*i/res);
			side1_point1=rotate_point (centre_angle, point1);
			side1_point2=rotate_point (centre_angle, point2);
			side2_point1=mirror_point (rotate_point (centre_angle, point1));
			side2_point2=mirror_point (rotate_point (centre_angle, point2));
			polygon (
				points=[[0,0],side1_point1,side1_point2,side2_point2,side2_point1],
				paths=[[0,1,2,3,4,0]]);
		}
	}
}

// Mathematical Functions
//===============

// Finds the angle of the involute about the base radius at the given distance (radius) from it's center.
//source: http://www.mathhelpforum.com/math-help/geometry/136011-circle-involute-solving-y-any-given-x.html

function involute_intersect_angle (base_radius, radius) = sqrt (pow (radius/base_radius, 2) - 1) * 180 / pi;

// Calculate the involute position for a given base radius and involute angle.

function rotated_involute (rotate, base_radius, involute_angle) =
[
	cos (rotate) * involute (base_radius, involute_angle)[0] + sin (rotate) * involute (base_radius, involute_angle)[1],
	cos (rotate) * involute (base_radius, involute_angle)[1] - sin (rotate) * involute (base_radius, involute_angle)[0]
];

function mirror_point (coord) =
[
	coord[0],
	-coord[1]
];

function rotate_point (rotate, coord) =
[
	cos (rotate) * coord[0] + sin (rotate) * coord[1],
	cos (rotate) * coord[1] - sin (rotate) * coord[0]
];

function involute (base_radius, involute_angle) =
[
	base_radius*(cos (involute_angle) + involute_angle*pi/180*sin (involute_angle)),
	base_radius*(sin (involute_angle) - involute_angle*pi/180*cos (involute_angle))
];


// Test Cases
//===============

module test_gears()
{
	translate([17,-15])
	{
		gear (number_of_teeth=17,
			circular_pitch=500,
			circles=8);

		rotate ([0,0,360*4/17])
		translate ([39.088888,0,0])
		{
			gear (number_of_teeth=11,
				circular_pitch=500,
				hub_diameter=0,
				rim_width=65);
			translate ([0,0,8])
			{
				gear (number_of_teeth=6,
					circular_pitch=300,
					hub_diameter=0,
					rim_width=5,
					rim_thickness=6,
					pressure_angle=31);
				rotate ([0,0,360*5/6])
				translate ([22.5,0,1])
				gear (number_of_teeth=21,
					circular_pitch=300,
					bore_diameter=2,
					hub_diameter=4,
					rim_width=1,
					hub_thickness=4,
					rim_thickness=4,
					gear_thickness=3,
					pressure_angle=31);
			}
		}

		translate ([-61.1111111,0,0])
		{
			gear (number_of_teeth=27,
				circular_pitch=500,
				circles=5,
				hub_diameter=2*8.88888889);

			translate ([-37.5,0,0])
			rotate ([0,0,-90])
			rack (
				circular_pitch=500
			     );

			translate ([0,0,10])
			{
				gear (
					number_of_teeth=14,
					circular_pitch=200,
					pressure_angle=5,
					clearance = 0.2,
					gear_thickness = 10,
					rim_thickness = 10,
					rim_width = 15,
					bore_diameter=5,
					circles=0);
				translate ([13.8888888,0,1])
				gear (
					number_of_teeth=11,
					circular_pitch=200,
					pressure_angle=5,
					clearance = 0.2,
					gear_thickness = 10,
					rim_thickness = 10,
					rim_width = 15,
					hub_thickness = 20,
					hub_diameter=2*7.222222,
					bore_diameter=5,
					circles=0);
			}
		}

		rotate ([0,0,360*-5/17])
		translate ([44.444444444,0,0])
		gear (number_of_teeth=15,
			circular_pitch=500,
			hub_diameter=10,
			rim_width=5,
			rim_thickness=5,
			gear_thickness=4,
			hub_thickness=6,
			circles=9);

		rotate ([0,0,360*-1/17])
		translate ([30.5555555,0,-1])
		gear (number_of_teeth=5,
			circular_pitch=500,
			hub_diameter=0,
			rim_width=5,
			rim_thickness=10);
	}
}

module meshing_double_helix ()
{
	test_double_helix_gear ();

	mirror ([0,1,0])
	translate ([58.33333333,0,0])
	test_double_helix_gear (teeth=13,circles=6);
}

module test_double_helix_gear (
	teeth=17,
	circles=8)
{
	//double helical gear
	{
		twist=200;
		height=20;
		pressure_angle=30;

		gear (number_of_teeth=teeth,
			circular_pitch=700,
			pressure_angle=pressure_angle,
			clearance = 0.2,
			gear_thickness = height/2*0.5,
			rim_thickness = height/2,
			rim_width = 5,
			hub_thickness = height/2*1.2,
			hub_diameter=15,
			bore_diameter=5,
			circles=circles,
			twist=twist/teeth);
		mirror([0,0,1])
		gear (number_of_teeth=teeth,
			circular_pitch=700,
			pressure_angle=pressure_angle,
			clearance = 0.2,
			gear_thickness = height/2,
			rim_thickness = height/2,
			rim_width = 5,
			hub_thickness = height/2,
			hub_diameter=15,
			bore_diameter=5,
			circles=circles,
			twist=twist/teeth);
	}
}

module test_backlash ()
{
	backlash = 2;
	teeth = 15;

	translate ([-29.166666,0,0])
	{
		translate ([58.3333333,0,0])
		rotate ([0,0,-360/teeth/4])
		gear (
			number_of_teeth = teeth,
			circular_pitch=700,
			gear_thickness = 12,
			rim_thickness = 15,
			rim_width = 5,
			hub_thickness = 17,
			hub_diameter=15,
			bore_diameter=5,
			backlash = 2,
			circles=8);

		rotate ([0,0,360/teeth/4])
		gear (
			number_of_teeth = teeth,
			circular_pitch=700,
			gear_thickness = 12,
			rim_thickness = 15,
			rim_width = 5,
			hub_thickness = 17,
			hub_diameter=15,
			bore_diameter=5,
			backlash = 2,
			circles=8);
	}

	color([0,0,128,0.5])
	translate([0,0,-5])
	cylinder ($fn=20,r=backlash / 4,h=25);
}
// Parametric curves, to be used as paths
// Licensed under the MIT license.
// © 2010 by Elmo Mäntynen
use <math.scad>
include <constants.scad>



/* A circular helix of radius a and pitch 2πb is described by the following parametrisation:
x(t) = a*cos(t),
y(t) = a*sin(t),
z(t) = b*t
*/


function b(pitch) = pitch/(TAU);
function t(pitch, z) = z/b(pitch);

function helix_curve(pitch, radius, z) =
    [radius*cos(deg(t(pitch, z))), radius*sin(deg(t(pitch, z))), z];

Code that could be integrated:
* http://github.com/l0b0/qr2scad
* http://github.com/l0b0/img2scad
* http://github.com/l0b0/OpenSCAD-Minimizer
* http://www.thingiverse.com/thing:4656
* http://www.thingiverse.com/thing:4758
* http://www.thingiverse.com/thing:6021
* Color library: http://www.thingiverse.com/thing:6717
* http://www.thingiverse.com/thing:6465

Integrate these better:
* bitmap

Testing:
* add tests for openscad functions
* motors.scad
* tests for 2D stuff

Code style:
* motors.scad
* nuts_and_bolts.scad
/**
 * Simple triangles library
 *
 * Authors:
 *   - Eero 'rambo' af Heurlin 2010-
 *
 * License: LGPL 2.1
 */


/**
 * Standard right-angled triangle
 *
 * @param number  o_len  Length of the opposite side
 * @param number  a_len  Length of the adjacent side
 * @param number  depth  How wide/deep the triangle is in the 3rd dimension
 * @param boolean center Whether to center the triangle on the origin
 * @todo a better way ?
 */
module triangle(o_len, a_len, depth, center=false)
{
    centroid = center ? [-a_len/3, -o_len/3, -depth/2] : [0, 0, 0];
    translate(centroid) linear_extrude(height=depth)
    {
        polygon(points=[[0,0],[a_len,0],[0,o_len]], paths=[[0,1,2]]);
    }
}

/**
 * Standard right-angled triangle (tangent version)
 *
 * @param number  tan_angle Angle of adjacent to hypotenuse (ie tangent)
 * @param number  a_len     Length of the adjacent side
 * @param number  depth     How wide/deep the triangle is in the 3rd dimension
 * @param boolean center    Whether to center the triangle on the origin
 */
module a_triangle(tan_angle, a_len, depth, center=false)
{
    triangle(tan(tan_angle) * a_len, a_len, depth, center);
}

// Tests:
module test_triangle() { triangle(5, 5, 5); }
module test_a_triangle() { a_triangle(45, 5, 5); }
module test_triangles()
{
    // Generate a bunch of triangles by sizes
    for (i = [1:10])
    {
        translate([i*7, -30, i*7])
        {
            triangle(i*5, sqrt(i*5+pow(i,2)), 5);
        }
    }

    // Generate a bunch of triangles by angle
    for (i = [1:85/5])
    {
        translate([i*7, 22, i*7])
        {
            a_triangle(i*5, 10, 5);
        }
    }
}
/*
 * Bearing model.
 *
 * Originally by Hans Häggström, 2010.
 * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later
 */

/*
change list 13/6/2013
 added ,604,606,607,628,629,6200,6201,6202,6203,6205,6206   bearing sizes 
*/

include <units.scad>
include <materials.scad>

// Example, uncomment to view
//test_bearing();
//test_bearing_hole();

module test_bearing(){
    bearing();
    bearing(pos=[5*cm, 0,0], angle=[90,0,0]);
    bearing(pos=[-2.5*cm, 0,0], model=688);
}

module test_bearing_hole(){
    difference(){
      translate([0, 0, 3.5]) cube(size=[30, 30, 7-10*epsilon], center=true);
      bearing(outline=true);
    }
}

BEARING_INNER_DIAMETER = 0;
BEARING_OUTER_DIAMETER = 1;
BEARING_WIDTH = 2;

// Common bearing names
SkateBearing = 608;

// Bearing dimensions
// model == XXX ? [inner dia, outer dia, width]:
// http://www.gizmology.net/bearings.htm has some valuable information on that
// https://www.bearingworks.com/bearing-sizes has a very exhaustive table of dimensions
function bearingDimensions(model) =
  model == 603 ? [3*mm,  9*mm,  5*mm]:
  model == 604 ? [4*mm, 12*mm,  4*mm]:
  model == 605 ? [5*mm, 14*mm,  5*mm]:
  model == 606 ? [6*mm, 17*mm,  6*mm]:
  model == 607 ? [7*mm, 19*mm,  6*mm]:
  model == 608 ? [8*mm, 22*mm,  7*mm]:
  model == 609 ? [9*mm, 24*mm,  7*mm]:

  model == 623 ? [3*mm, 10*mm,  4*mm]:
  model == 624 ? [4*mm, 13*mm,  5*mm]:
  model == 625 ? [5*mm, 16*mm,  5*mm]:
  model == 626 ? [6*mm, 19*mm,  6*mm]:
  model == 627 ? [7*mm, 22*mm,  7*mm]:
  model == 628 ? [8*mm, 24*mm,  8*mm]:
  model == 629 ? [9*mm, 26*mm,  8*mm]:

  model == 633 ? [3*mm, 13*mm,  5*mm]:
  model == 634 ? [4*mm, 16*mm,  5*mm]:
  model == 635 ? [5*mm, 19*mm,  6*mm]:
  model == 636 ? [6*mm, 22*mm,  7*mm]:
  model == 637 ? [7*mm, 26*mm,  9*mm]:
  model == 638 ? [8*mm, 28*mm,  9*mm]:
  model == 639 ? [9*mm, 30*mm, 10*mm]:

  model == 673 ? [3*mm,  6*mm,  2.5*mm]:
  model == 674 ? [4*mm,  7*mm,  2.5*mm]:
  model == 675 ? [5*mm,  8*mm,  2.5*mm]:
  model == 676 ? [6*mm, 10*mm,  3*mm]:
  model == 677 ? [7*mm, 11*mm,  3*mm]:
  model == 678 ? [8*mm, 12*mm,  3.5*mm]:

  model == 683 ? [3*mm,  7*mm,  3*mm]:
  model == 684 ? [4*mm,  9*mm,  4*mm]:
  model == 685 ? [5*mm, 11*mm,  5*mm]:
  model == 686 ? [6*mm, 13*mm,  5*mm]:
  model == 687 ? [7*mm, 14*mm,  5*mm]:
  model == 688 ? [8*mm, 16*mm,  5*mm]:
  model == 689 ? [9*mm, 17*mm,  5*mm]:

  model == 693 ? [3*mm,  8*mm,  4*mm]:
  model == 694 ? [4*mm, 11*mm,  4*mm]:
  model == 695 ? [5*mm, 13*mm,  4*mm]:
  model == 696 ? [6*mm, 15*mm,  5*mm]:
  model == 697 ? [7*mm, 17*mm,  5*mm]:
  model == 698 ? [8*mm, 19*mm,  6*mm]:
  model == 699 ? [9*mm, 20*mm,  6*mm]:

  model == 6200 ? [10*mm, 30*mm, 9*mm]:
  model == 6201 ? [12*mm, 32*mm, 10*mm]:
  model == 6202 ? [15*mm, 35*mm, 11*mm]:
  model == 6203 ? [17*mm, 40*mm, 12*mm]:
  model == 6205 ? [25*mm, 52*mm, 15*mm]:
  model == 6206 ? [30*mm, 62*mm, 16*mm]:
  
  model == 6808 ? [40*mm, 52*mm, 7*mm]:

  [8*mm, 22*mm, 7*mm]; // this is the default


function bearingWidth(model) = bearingDimensions(model)[BEARING_WIDTH];
function bearingInnerDiameter(model) = bearingDimensions(model)[BEARING_INNER_DIAMETER];
function bearingOuterDiameter(model) = bearingDimensions(model)[BEARING_OUTER_DIAMETER];

module bearing(pos=[0,0,0], angle=[0,0,0], model=SkateBearing, outline=false,
                material=Steel, sideMaterial=Brass) {
  // Common bearing names
  model =
    model == "Skate" ? 608 :
    model;

  w = bearingWidth(model);
  innerD = outline==false ? bearingInnerDiameter(model) : 0;
  outerD = bearingOuterDiameter(model);

  innerRim = innerD + (outerD - innerD) * 0.2;
  outerRim = outerD - (outerD - innerD) * 0.2;
  midSink = w * 0.1;

  translate(pos) rotate(angle) union() {
    color(material)
      difference() {
        // Basic ring
        Ring([0,0,0], outerD, innerD, w, material, material);

        if (outline==false) {
          // Side shields
          Ring([0,0,-epsilon], outerRim, innerRim, epsilon+midSink, sideMaterial, material);
          Ring([0,0,w-midSink], outerRim, innerRim, epsilon+midSink, sideMaterial, material);
        }
      }
  }

  module Ring(pos, od, id, h, material, holeMaterial) {
    color(material) {
      translate(pos)
        difference() {
          cylinder(r=od/2, h=h,  $fs = 0.01);
          color(holeMaterial)
            translate([0,0,-10*epsilon])
              cylinder(r=id/2, h=h+20*epsilon,  $fs = 0.01);
        }
    }
  }

}


/*
 * Basic units.
 * 
 * Originally by Hans Häggström, 2010.
 * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later
 */


mm = 1;
cm = 10 * mm;
dm = 100 * mm;
m = 1000 * mm;

inch = 25.4 * mm;

X = [1, 0, 0];
Y = [0, 1, 0];
Z = [0, 0, 1];

M3 = 3*mm;
M4 = 4*mm;
M5 = 5*mm;
M6 = 6*mm;
M8 = 8*mm;


// When a small distance is needed to overlap shapes for boolean cutting, etc.
epsilon = 0.01*mm;

// Copyright 2011 Nophead (of RepRap fame)
// This file is licensed under the terms of Creative Commons Attribution 3.0 Unported.

// Using this holes should come out approximately right when printed
module polyhole(h, d=0, r=0, center=false) {
    _r = (r == 0 ? d / 2 : r);
    _d = (d == 0 ? r * 2 : d);

    n = max(round(2 * _d),3);

    rotate([0,0,180])
        cylinder(h = h, r = (_d / 2) / cos (180 / n), $fn = n, center=center);
}

module test_polyhole(){
difference() {
    cube(size = [100,27,3]);
    union() {
        for(i = [1:10]) {
            translate([(i * i + i)/2 + 3 * i , 8,-1])
                polyhole(h = 5, d = i);

            assign(d = i + 0.5)
                translate([(d * d + d)/2 + 3 * d, 19,-1])
                    polyhole(h = 5, d = d);
        }
    }
}
}
// array functions
// by david powell 
// licence LGPL V2 or later 
//
// this lib provides 2 functions 
// Cubic_Array() , and Radial_Array()
//
//Cubic_Array(sx,sy,sz,nx,ny,nz,center){childobject}
//  produces a cubic grid of child objects 
//  sx,sy,sz = spacing for each axis 
//  nx,ny,nz and number of objects on each axis 
//  center = true/false on if geometery is centered or not 
//
//
//Radial_Array(a,n,r){child object}
// produces a clockwise radial array of child objects rotated around the local z axis   
// a= interval angle 
// n= number of objects 
// r= radius distance 
//
// remove // from following line to run test 
//Cubic_and_Radial_Array_Test();

module Cubic_and_Radial_Array_Test()
  {
//center referance point 
 	translate([0,0,0])
	#cube([5,5,5],center=true);

//cubic array  of  5*5*5 objects spaced 10*10*10 center relative
 	Cubic_Array(10,10,10,5,5,5,center=true)
		{
			sphere(2.5,$fn=60);
			cylinder(h=10,r=.5,center=true);
			rotate([90,0,0])
			cylinder(h=10,r=.5,center=true);
			rotate([0,90,0])
			cylinder(h=10,r=.5,center=true);
		}

//a linear array allong x can be derived from the cubic array simply 
	translate([60,0,0])
   Cubic_Array(10,0,0,5,1,1,center=false)
		{
		cube([5,5,5],center=true);
		} 
//a linear array allong y can be derived from the cubic array simply 
	translate([0,60,0])
   Cubic_Array(0,10,0,1,5,1,center=false)
		{
		cube([5,5,5],center=true);
		} 

//a linear array allong z can be derived from the cubic array simply 
	translate([0,0,60])
   Cubic_Array(0,0,10,1,1,5,center=false)
		{
		cube([5,5,5],center=true);
		} 

//a grid  array allong x,y can be derived from the cubic array simply 
	translate([0,0,-60])
   Cubic_Array(10,10,0,5,5,1,center=true)
		{
		cube([5,5,5],center=true);
		} 

//radial array of 32 objects rotated though 10 degrees 
 	translate([0,0,0])
 	Radial_Array(10,32,40)
		{
		cube([2,4,6],center=true);
		}

// a radial array of linear arrays 

 	rotate([45,45,45])
  	Radial_Array(10,36,40)
		{
		translate([0,10,0])
   	Cubic_Array(0,10,0,1,5,1,center=false)
			{
			cube([2,3,4],center=true);
			cylinder(h=10,r=.5,center=true);
			rotate([90,0,0])
			cylinder(h=10,r=.5,center=true);
			}
		}

}


// main lib modules
module Cubic_Array(sx,sy,sz,nx,ny,nz,center) {
	offset = center ? [-(((nx+1)*sx)/2),-(((ny+1)*sy)/2),-(((nz+1)*sz)/2)] : [0,0,0];
	translate(offset)
		for(x=[1:nx], y=[1:ny], z=[1:nz])
			translate([x*sx,y*sy,z*sz])
				children();
}

//
//Radial_Array(a,n,r){child object}
// produces a clockwise radial array of child objects rotated around the local z axis   
// a= interval angle 
// n= number of objects 
// r= radius distance 
//
module Radial_Array(a,n,r){
	for (k=[0:n-1])
		rotate([0,0,-(a*k)])
			translate([0,r,0])
				children();
}
// Font Functions
// Encoding from http://en.wikipedia.org/wiki/ASCII
// Author: Andrew Plumb
// License: LGPL 2.1

module outline_2d(outline,points,paths,width=0.1,resolution=8) {
  if(outline && resolution > 4) {
    for(j=[0:len(paths)-1]) union() {
      for(i=[1:len(paths[j])-1]) hull() {
            translate(points[paths[j][i-1]]) circle($fn=resolution,r=width/2);
            translate(points[paths[j][i]]) circle($fn=resolution,r=width/2);
      }
      hull() {
            translate(points[paths[j][len(paths[j])-1]]) circle($fn=resolution,r=width/2);
            translate(points[paths[j][0]]) circle($fn=resolution,r=width/2);
      }
    }
  } else {
      polygon(points=points,paths=paths);
  }
}

module bold_2d(bold,width=0.2,resolution=8) {
  for(j=[0:$children-1]) {
    if(bold) {
      union() {
            children(j);
        for(i=[0:resolution-1]) {
            dx=width*cos(360*i/resolution);
            dy=width*sin(360*i/resolution);
            translate([dx,dy]) children(j);
        }
      }
    } else {
      children(j);
    }
  }
}

module polytext(charstring,size,font,line=0,justify=1,align=-1
	,bold=false,bold_width=0.2,bold_resolution=8
	,underline=false,underline_start=[0,0],underline_width=1.0
	,outline=false,outline_width=0.2,outline_resolution=8
	,strike=false,strike_start=[-0.5,0],strike_width=1.0
	) {
  line_length=len(charstring)*font[0][0];
  line_shift_x=-line_length/2+justify*line_length/2;
  char_width=font[0][0];
  char_height=font[0][1];
  char_shift_height=-char_height/2-align*char_height/2;
  char_thickness=font[0][2];
  char_index_map=search(charstring,font[2],1,1);
  for(i=[0:len(char_index_map)-1]) {
    thisCharIndex=char_index_map[i];
    x_pos=i*size+line_shift_x*size/char_width;
    translate([x_pos,line*size+char_shift_height*size/char_height]) scale([size/char_width,size/char_height]) {
      if(char_thickness==0)
        bold_2d(bold,width=bold_width,resolution=bold_resolution)
          outline_2d(outline,points=font[2][thisCharIndex][6][0],paths=font[2][thisCharIndex][6][1]
              ,width=outline_width,resolution=outline_resolution);
      if( charstring[i] != " " ) {
        if(underline) translate(underline_start)
	  square(size=[char_width-2*underline_start[0],underline_width],center=false);
        if(strike) translate([strike_start[0],char_height/2+strike_start[1]])
          square(size=[char_width-2*strike_start[0],strike_width],center=false);
      }
      if(char_thickness>0)
          polyhedron(points=font[2][thisCharIndex][6][0],triangles=font[2][thisCharIndex][6][1]);
    }
  }
}


function 8bit_polyfont(dx=0.1,dy=0.1) = [
  [8,8,0,"fixed"],["Decimal Byte","Caret Notation","Character Escape Code","Abbreviation","Name","Bound Box","[points,paths]"]
  ,[
   [  0,"^@","\0","NUL","Null character",[[0,0],[8,8]],[]]
  ,[  1,"^A","",  "SOH","Start of Header",[[0,0],[8,8]],[]]
  ,[  2,"^B","",  "STX","Start of Text",[[0,0],[8,8]],[]]
  ,[  3,"^C","",  "ETX","End of Text",[[0,0],[8,8]],[]]
  ,[  4,"^D","",  "EOT","End of Transmission",[[0,0],[8,8]],[]]
  ,[  5,"^E","",  "ENQ","Enquiry",[[0,0],[8,8]],[]]
  ,[  6,"^F","",  "ACK","Acknowledgment",[[0,0],[8,8]],[]]
  ,[  7,"^G","\a","BEL","Bell",[[0,0],[8,8]],[]]
  ,[  8,"^H","\b","BS", "Backspace",[[0,0],[8,8]],[]]
  ,[  9,"^I","\t","HT", "Horizontal Tab",[[0,0],[8,8]],[]]
  ,[ 10,"^J","\n","LF", "Line Feed",[[0,0],[8,8]],[]]
  ,[ 11,"^K","\v","VT", "Vertical Tab",[[0,0],[8,8]],[]]
  ,[ 12,"^L","\f","FF", "Form feed",[[0,0],[8,8]],[]]
  ,[ 13,"^M","\r","CR", "Carriage return",[[0,0],[8,8]],[]]
  ,[ 14,"^N","",  "SO", "Shift Out",[[0,0],[8,8]],[]]
  ,[ 15,"^O","",  "SI", "Shift In",[[0,0],[8,8]],[]]
  ,[ 16,"^P","",  "DLE","Data Link Escape",[[0,0],[8,8]],[]]
  ,[ 17,"^Q","",  "DC1","Device Control 1",[[0,0],[8,8]],[]]
  ,[ 18,"^R","",  "DC2","Device Control 2",[[0,0],[8,8]],[]]
  ,[ 19,"^S","",  "DC3","Device Control 3",[[0,0],[8,8]],[]]
  ,[ 20,"^T","",  "DC4","Device Control 4",[[0,0],[8,8]],[]]
  ,[ 21,"^U","",  "NAK","Negative Acknowledgement",[[0,0],[8,8]],[]]
  ,[ 22,"^V","",  "SYN","Synchronous Idle",[[0,0],[8,8]],[]]
  ,[ 23,"^W","",  "ETB","End of Transmission Block",[[0,0],[8,8]],[]]
  ,[ 24,"^X","",  "CAN","Cancel",[[0,0],[8,8]],[]]
  ,[ 25,"^Y","",  "EM", "End of Medium",[[0,0],[8,8]],[]]
  ,[ 26,"^Z","",  "SUB","Substitute",[[0,0],[8,8]],[]]
  ,[ 27,"^[","\e","ESC","Escape",[[0,0],[8,8]],[]]
  ,[ 28,"^\\","", "FS", "File Separator",[[0,0],[8,8]],[]]
  ,[ 29,"^]","",  "GS", "Group Separator",[[0,0],[8,8]],[]]
  ,[ 30,"^^","",  "RS", "Record Separator",[[0,0],[8,8]],[]]
  ,[ 31,"^_","",  "US", "Unit Separator",[[0,0],[8,8]],[]]
  ,[ 32," "," ",  "", "Space",[[0,0],[2,8]],[]]
  ,[ 33,"!","!",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[5,2],[5,1]
	,[3,3],[3,7],[5,7],[5,3]]
	,[[0,1,2,3],[4,5,6,7]]
	]]
  ,[ 34,"\"","\"","", "",[[0,0],[8,8]],[
	[[1,4],[1,7],[3,7],[3,4]
	,[5,4],[5,7],[7,7],[7,4]]
	,[[0,1,2,3],[4,5,6,7]]
	]]
  ,[ 35,"#","#",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[0,2],[0,3],[1,3],[1,5],[0,5],[0,6],[1,6],[1,7],[3,7],[3,6],[5,6],[5,7],[7,7]
		,[7,6],[8,6],[8,5],[7,5],[7,3],[8,3],[8,2],[7,2],[7,1],[5,1],[5,2],[3,2],[3,1]
	,[3,3],[3,5],[5,5],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27],[28,29,30,31]]
	]]
  ,[ 36,"$","$",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[1,2],[1,3],[5,3],[5,4],[2,4],[2,5],[1,5],[1,6],[2,6],[2,7],[3,7],[3,8],[5,8],[5,7],[7,7],[7,6]
		,[3,6],[3,5],[6,5],[6,4],[7,4],[7,3],[6,3],[6,2],[5,2],[5,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 37,"%","%",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,3],[2,3],[2,5],[1,5],[1,7],[3,7],[3,5],[4,5],[4,6],[5,6],[5,7],[7,7]
		,[7,6],[6,6],[6,5],[5,5],[5,4],[4,4],[4,3],[3,3],[3,2],[2,2],[2,1]
	,[5,1],[5,3],[7,3],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23],[24,25,26,27]]
	]]
  ,[ 38,"&","&",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,4],[2,4],[2,5],[3,5],[3,6],[2,6],[2,7],[3,7],[3,8],[6,8],[6,7],[7,7],[7,6],[6,6],[6,5],[5,5],[5,4]
		,[8,4],[8,3],[7,3],[7,2],[8,2],[8,1],[6,1],[6,2],[5,2],[5,1]
	,[3,2],[3,4],[4,4],[4,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],[30,31,32,33]]
	]]
  ,[ 39,"'","'",  "", "",[[0,0],[8,8]],[
	[[3,4],[3,7],[5,7],[5,4]]
	,[[0,1,2,3]]
	]]
  ,[ 40,"(","(",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[2,2],[2,6],[3,6],[3,7],[6,7],[6,6],[5,6],[5,5],[4,5],[4,3],[5,3],[5,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[ 41,")",")",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[3,2],[3,3],[4,3],[4,5],[3,5],[3,6],[2,6],[2,7],[5,7],[5,6],[6,6],[6,2],[5,2],[5,1],[4,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]]
	]]
  ,[ 42,"*","*",  "", "",[[0,0],[8,8]],[
	[[1,2],[1,3],[2,3],[2,4],[0,4],[0,5],[2,5],[2,6],[1,6],[1,7],[3,7],[3,6],[5,6],[5,7],[7,7],[7,6],[6,6]
		,[6,5],[8,5],[8,4],[6,4],[6,3],[7,3],[7,2],[5,2],[5,3],[3,3],[3,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 43,"+","+",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,3],[1,3],[1,5],[3,5],[3,7],[5,7],[5,5],[7,5],[7,3],[5,3],[5,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[ 44,",",",",  "", "",[[0,0],[8,8]],[
	[[2,0],[2,1],[3,1],[3,3],[5,3],[5,1],[4,1],[4,0]]
	,[[0,1,2,3,4,5,6,7]]
	]]
  ,[ 45,"-","-",  "", "",[[0,0],[8,8]],[
	[[1,3],[1,5],[7,5],[7,3]]
	,[[0,1,2,3]]
	]]
  ,[ 46,".",".",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,3],[5,3],[5,1]]
	,[[0,1,2,3]]
	]]
  ,[ 47,"/","/",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,3],[2,3],[2,4],[3,4],[3,5],[4,5],[4,6],[5,6],[5,7],[7,7],[7,6],[6,6],[6,5],[5,5],[5,4],[4,4],[4,3],[3,3],[3,2],[2,2],[2,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]]
	]]
  ,[ 48,"0","0",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,2],[6,2],[6,1]
	,[3,2],[3,3],[5,3],[5,2]
	,[3,4],[3,6],[5,6],[5,5],[4,5],[4,4]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15],[16,17,18,19,20,21]]
	]]
  ,[ 49,"1","1",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[3,2],[3,5],[2,5],[2,6],[3,6],[3,7],[5,7],[5,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[ 50,"2","2",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[2,2],[2,3],[3,3],[3,4],[4,4],[4,5],[5,5],[5,6],[3,6],[3,5],[1,5],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,5],[6,5],[6,4],[5,4],[5,3],[4,3],[4,2],[3,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]]
	]]
  ,[ 51,"3","3",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,3],[3,3],[3,2],[5,2],[5,3],[4,3],[4,4],[3,4],[3,5],[4,5],[4,6],[1,6],[1,7],[7,7],[7,6],[6,6],[6,5],[5,5],[5,4],[6,4],[6,3],[7,3],[7,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 52,"4","4",  "", "",[[0,0],[8,8]],[
	[[4,1],[4,2],[1,2],[1,4],[2,4],[2,5],[3,5],[3,6],[4,6],[4,7],[6,7],[6,3],[7,3],[7,2],[6,2],[6,1]
	,[3,3],[3,4],[4,4],[4,3]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19]]
	]]
  ,[ 53,"5","5",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,3],[3,3],[3,2],[5,2],[5,4],[1,4],[1,7],[7,7],[7,6],[3,6],[3,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 54,"6","6",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[3,6],[3,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]
	,[3,2],[3,4],[5,4],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19]]
	]]
  ,[ 55,"7","7",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,3],[3,3],[3,4],[4,4],[4,5],[5,5],[5,6],[1,6],[1,7],[7,7],[7,5],[6,5],[6,4],[5,4],[5,3],[4,3],[4,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]]
	]]
  ,[ 56,"8","8",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,4],[2,4],[2,5],[1,5],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]
	,[3,2],[3,4],[5,4],[5,2]
	,[3,5],[3,6],[5,6],[5,5]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],[20,21,22,23],[24,25,26,27]]
	]]
  ,[ 57,"9","9",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[4,2],[4,3],[5,3],[5,4],[2,4],[2,5],[1,5],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,3],[6,3],[6,2],[5,2],[5,1]
	,[3,5],[3,6],[5,6],[5,5]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],[20,21,22,23]]
	]]
  ,[ 58,":",":",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,3],[5,3],[5,1]
	,[3,4],[3,6],[5,6],[5,4]]
	,[[0,1,2,3],[4,5,6,7]]
	]]
  ,[ 59,";",";",  "", "",[[0,0],[8,8]],[
	[[2,0],[2,1],[3,1],[3,3],[5,3],[5,1],[4,1],[4,0]
	,[3,4],[3,6],[5,6],[5,4]]
	,[[0,1,2,3,4,5,6,7],[8,9,10,11]]
	]]
  ,[ 60,"<","<",  "", "",[[0,0],[8,8]],[
	[[5,1],[5,2],[4,2],[4,3],[3,3],[3,4],[2,4],[2,5],[3,5],[3,6],[4,6],[4,7],[5,7],[5,8],[7,8],[7,7],[6,7],[6,6],[5,6],[5,5],[4,5],[4,4],[5,4],[5,3],[6,3],[6,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 61,"=","=",  "", "",[[0,0],[8,8]],[
	[[1,2],[1,3],[7,3],[7,2]
	,[1,5],[1,6],[7,6],[7,5]]
	,[[0,1,2,3],[4,5,6,7]]
	]]
  ,[ 62,">",">",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[2,2],[2,3],[3,3],[3,4],[4,4],[4,5],[3,5],[3,6],[2,6],[2,7],[1,7],[1,8],[3,8],[3,7],[4,7],[4,6],[5,6],[5,5],[6,5],[6,4],[5,4],[5,3],[4,3],[4,2],[3,2],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 63,"?","?",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[5,2],[5,1]
	,[3,3],[3,4],[4,4],[4,5],[5,5],[5,6],[3,6],[3,5],[1,5],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,5],[6,5],[6,4],[5,4],[5,3]]
	,[[0,1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]]
	]]
  ,[ 64,"@","@",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,3],[4,3],[4,5],[5,5],[5,6],[3,6],[3,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]]
	]]
  ,[ 65,"A","A",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,5],[2,5],[2,6],[3,6],[3,7],[5,7],[5,6],[6,6],[6,5],[7,5],[7,1],[5,1],[5,2],[3,2],[3,1]
	,[3,3],[3,5],[5,5],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19]]
	]]
  ,[ 66,"B","B",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[6,7],[6,6],[7,6],[7,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]
	,[3,5],[3,6],[5,6],[5,5]
	,[3,2],[3,4],[5,4],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15],[16,17,18,19]]
	]]
  ,[ 67,"C","C",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,5],[5,5],[5,6],[3,6],[3,2],[5,2],[5,3],[7,3],[7,2],[6,2],[6,1]]	    ,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 68,"D","D",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[5,7],[5,6],[6,6],[6,5],[7,5],[7,3],[6,3],[6,2],[5,2],[5,1]
	,[3,2],[3,6],[4,6],[4,5],[5,5],[5,3],[4,3],[4,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15,16,17,18,19]]
	]]
  ,[ 69,"E","E",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[7,7],[7,6],[3,6],[3,5],[6,5],[6,4],[3,4],[3,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[ 70,"F","F",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[7,7],[7,6],[3,6],[3,5],[6,5],[6,4],[3,4],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9]]
	]]
  ,[ 71,"G","G",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[7,7],[7,6],[3,6],[3,2],[5,2],[5,3],[4,3],[4,4],[7,4],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[ 72,"H","H",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,5],[5,5],[5,7],[7,7],[7,1],[5,1],[5,4],[3,4],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[ 73,"I","I",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[3,2],[3,6],[1,6],[1,7],[7,7],[7,6],[5,6],[5,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[ 74,"J","J",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,3],[3,3],[3,2],[5,2],[5,6],[4,6],[4,7],[7,7],[7,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13]]
	]]
  ,[ 75,"K","K",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,5],[4,5],[4,6],[5,6],[5,7],[7,7],[7,6],[6,6],[6,5],[5,5],[5,3],[6,3],[6,2],[7,2],[7,1],[5,1],[5,2],[4,2],[4,3],[3,3],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]]
	]]
  ,[ 76,"L","L",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5]]
	]]
  ,[ 77,"M","M",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,6],[4,6],[4,5],[5,5],[5,6],[6,6],[6,7],[8,7],[8,1],[6,1],[6,4],[5,4],[5,3],[4,3],[4,4],[3,4],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 78,"N","N",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,6],[4,6],[4,5],[5,5],[5,7],[7,7],[7,1],[5,1],[5,2],[4,2],[4,3],[3,3],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[ 79,"O","O",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,2],[6,2],[6,1]
	,[3,2],[3,6],[5,6],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]
	]]
  ,[ 80,"P","P",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[6,7],[6,6],[7,6],[7,4],[6,4],[6,3],[3,3],[3,1]
	,[3,4],[3,6],[5,6],[5,4]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[ 81,"Q","Q",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[2,6],[2,7],[6,7],[6,6],[7,6],[7,3],[6,3],[6,2],[7,2],[7,1],[5,1],[5,2],[4,2],[4,1]
	,[3,3],[3,6],[5,6],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],[18,19,20,21]]
	]]
  ,[ 82,"R","R",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[6,7],[6,6],[7,6],[7,4],[6,4],[6,2],[7,2],[7,1],[5,1],[5,2],[4,2],[4,3],[3,3],[3,1]
	,[3,4],[3,6],[5,6],[5,4]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19]]
	]]
  ,[ 83,"S","S",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[5,2],[5,4],[2,4],[2,5],[1,5],[1,6],[2,6],[2,7],[6,7],[6,6],[3,6],[3,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 84,"T","T",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,6],[1,6],[1,7],[7,7],[7,6],[5,6],[5,1]]
	,[[0,1,2,3,4,5,6,7]]
	]]
  ,[ 85,"U","U",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,2],[5,2],[5,7],[7,7],[7,1]]
	,[[0,1,2,3,4,5,6,7]]
	]]
  ,[ 86,"V","V",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[2,2],[2,3],[1,3],[1,7],[3,7],[3,3],[5,3],[5,7],[7,7],[7,3],[6,3],[6,2],[5,2],[5,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[ 87,"W","W",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,4],[4,4],[4,5],[5,5],[5,4],[6,4],[6,7],[8,7],[8,1],[6,1],[6,2],[5,2],[5,3],[4,3],[4,2],[3,2],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 88,"X","X",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,3],[2,3],[2,5],[1,5],[1,7],[3,7],[3,5],[5,5],[5,7],[7,7],[7,5],[6,5],[6,3],[7,3],[7,1],[5,1],[5,3],[3,3],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[ 89,"Y","Y",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,4],[2,4],[2,5],[1,5],[1,7],[3,7],[3,5],[5,5],[5,7],[7,7],[7,5],[6,5],[6,4],[5,4],[5,1],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]]
	]]
  ,[ 90,"Z","Z",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,3],[2,3],[2,4],[3,4],[3,5],[4,5],[4,6],[1,6],[1,7],[7,7],[7,6],[6,6],[6,5],[5,5],[5,4],[4,4],[4,3],[3,3],[3,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]]
	]]
  ,[ 91,"[","[",  "", "",[[0,0],[8,8]],[ // ] ]
	[[2,1],[2,7],[6,7],[6,6],[4,6],[4,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7]]
	]]
  ,[ 92,"\\","\\","", "",[[0,0],[8,8]],[
	[[6,1],[6,2],[5,2],[5,3],[4,3],[4,4],[3,4],[3,5],[2,5],[2,6],[1,6],[1,7],[3,7],[3,6],[4,6],[4,5],[5,5],[5,4],[6,4],[6,3],[7,3],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]]
	]] 
  ,[ 93,"]","]",  "", "",[[0,0],[8,8]],[  // [ [ 
	[[2,1],[2,2],[4,2],[4,6],[2,6],[2,7],[6,7],[6,1]]
	,[[0,1,2,3,4,5,6,7]]
	]]
  ,[ 94,"^","^",  "", "",[[0,0],[8,8]],[
	[[2,4],[2,5]
		,[3-dx,5],[3,5+dy]
	,[3,6]
		,[4-dx,6],[4,6+dy]
	,[4,7],[5,7]
		,[5,6+dy],[5+dx,6]
	,[6,6]
		,[6,5+dy],[6+dx,5]
	,[7,5],[7,4],[6,4]
		,[6,5-dy],[6-dx,5]
	,[5,5]
		,[5,6-dy],[5-dx,6],[4+dx,6],[4,6-dy]
	,[4,5]
		,[3+dx,5],[3,5-dy]
	,[3,4]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[ 95,"_","_",  "", "",[[0,0],[8,8]],[
	[[0,0],[0,1],[8,1],[8,0]]
	,[[0,1,2,3]]
	]]
  ,[ 96,"`","`",  "", "",[[0,0],[8,8]],[
	[[2,6],[2,7],[3,7]
		,[3,6+dy],[3+dx,6]
	,[4,6]
		,[4,5+dy],[4+dx,5]
	,[5,5],[5,4],[4,4]
		,[4,5-dy],[4-dx,5]
	,[3,5]
		,[3,6-dy],[3-dx,6]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[ 97,"a","a",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,3],[2,3],[2,4],[5,4],[5,5],[2,5],[2,6],[6,6],[6,5],[7,5],[7,1]
	,[3,2],[3,3],[5,3],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13],[14,15,16,17]]
	]]
  ,[ 98,"b","b",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,5],[6,5],[6,4],[7,4],[7,2],[6,2],[6,1]
	,[3,2],[3,4],[5,4],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[ 99,"c","c",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,5],[2,5],[2,6],[6,6],[6,5],[3,5],[3,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[100,"d","d",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,4],[2,4],[2,5],[5,5],[5,7],[7,7],[7,1]
	,[3,2],[3,4],[5,4],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[101,"e","e",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,5],[2,5],[2,6],[6,6],[6,5],[7,5],[7,3],[3,3],[3,2],[6,2],[6,1]
	,[3,4],[3,5],[5,5],[5,4]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13],[14,15,16,17]]
	]]
  ,[102,"f","f",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,4],[2,4],[2,5],[3,5],[3,6],[4,6],[4,7],[7,7],[7,6],[5,6],[5,5],[7,5],[7,4],[5,4],[5,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[103,"g","g",  "", "",[[0,0],[8,8]],[
	[[1,0],[1,1],[5,1],[5,2],[2,2],[2,3],[1,3],[1,5],[2,5],[2,6],[6,6],[6,5],[7,5],[7,1],[6,1],[6,0]
	,[3,3],[3,5],[5,5],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19]]
	]]
  ,[104,"h","h",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,5],[6,5],[6,4],[7,4],[7,1],[5,1],[5,4],[3,4],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11]]
	]]
  ,[105,"i","i",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[3,2],[3,4],[2,4],[2,5],[5,5],[5,2],[6,2],[6,1]
	,[3,6],[3,7],[5,7],[5,6]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[106,"j","j",  "", "",[[0,0],[8,8]],[
	[[2,0],[2,1],[5,1],[5,5],[7,5],[7,1],[6,1],[6,0]
	,[5,6],[5,7],[7,7],[7,6]]
	,[[0,1,2,3,4,5,6,7],[8,9,10,11]]
	]]
  ,[107,"k","k",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,7],[3,7],[3,4],[4,4],[4,5],[6,5],[6,4],[5,4],[5,3],[6,3],[6,2],[7,2],[7,1],[5,1],[5,2],[4,2],[4,3],[3,3],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[108,"l","l",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[3,2],[3,6],[2,6],[2,7],[5,7],[5,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9]]
	]]
  ,[109,"m","m",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,6],[3,6],[3,5],[5,5],[5,6],[7,6],[7,5],[8,5],[8,1],[6,1],[6,3],[5,3],[5,2],[4,2],[4,3],[3,3],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]]
	]]
  ,[110,"n","n",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,6],[6,6],[6,5],[7,5],[7,1],[5,1],[5,5],[3,5],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9]]
	]]
  ,[111,"o","o",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,5],[2,5],[2,6],[6,6],[6,5],[7,5],[7,2],[6,2],[6,1]
	,[3,2],[3,5],[5,5],[5,2]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]
	]]
  ,[112,"p","p",  "", "",[[0,0],[8,8]],[
	[[1,0],[1,6],[6,6],[6,5],[7,5],[7,3],[6,3],[6,2],[3,2],[3,0]
	,[3,3],[3,5],[5,5],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[113,"q","q",  "", "",[[0,0],[8,8]],[
	[[5,0],[5,2],[2,2],[2,3],[1,3],[1,5],[2,5],[2,6],[7,6],[7,0]
	,[3,3],[3,5],[5,5],[5,3]]
	,[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]
	]]
  ,[114,"r","r",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,6],[6,6],[6,5],[7,5],[7,4],[5,4],[5,5],[3,5],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9]]
	]]
  ,[115,"s","s",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[5,2],[5,3],[2,3],[2,4],[1,4],[1,5],[2,5],[2,6],[7,6],[7,5],[3,5],[3,4],[6,4],[6,3],[7,3],[7,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[116,"t","t",  "", "",[[0,0],[8,8]],[
	[[4,1],[4,2],[3,2],[3,5],[1,5],[1,6],[3,6],[3,7],[5,7],[5,6],[7,6],[7,5],[5,5],[5,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[117,"u","u",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[1,2],[1,6],[3,6],[3,2],[5,2],[5,6],[7,6],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9]]
	]]
  ,[118,"v","v",  "", "",[[0,0],[8,8]],[
	[[3,1],[3,2],[2,2],[2,3],[1,3],[1,6],[3,6],[3,3],[5,3],[5,6],[7,6],[7,3],[6,3],[6,2],[5,2],[5,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]
	]]
  ,[119,"w","w",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,3],[1,3],[1,6],[3,6],[3,4],[4,4],[4,5],[5,5],[5,4],[6,4],[6,6],[8,6],[8,3],[7,3],[7,1],[5,1],[5,2],[4,2],[4,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[120,"x","x",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[2,2],[2,3],[3,3],[3,4],[2,4],[2,5],[1,5],[1,6],[3,6],[3,5],[5,5],[5,6],[7,6],[7,5],[6,5],[6,4],[5,4],[5,3],[6,3],[6,2],[7,2],[7,1],[5,1],[5,2],[3,2],[3,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]]
	]]
  ,[121,"y","y",  "", "",[[0,0],[8,8]],[
	[[1,0],[1,1],[4,1],[4,2],[2,2],[2,3],[1,3],[1,6],[3,6],[3,3],[5,3],[5,6],[7,6],[7,2],[6,2],[6,1],[5,1],[5,0]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]]
	]]
  ,[122,"z","z",  "", "",[[0,0],[8,8]],[
	[[1,1],[1,2],[2,2],[2,3],[3,3],[3,4],[4,4],[4,5],[1,5],[1,6],[7,6],[7,5],[6,5],[6,4],[5,4],[5,3],[4,3],[4,2],[7,2],[7,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[123,"{","{",  "", "",[[0,0],[8,8]],[
	[[4,1],[4,2],[3,2],[3,4],[2,4],[2,5],[3,5],[3,7],[4,7],[4,8],[6,8],[6,7],[5,7],[5,5],[4,5],[4,4],[5,4],[5,2],[6,2],[6,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[124,"|","|",  "", "",[[0,0],[8,8]],[
	[[3,0],[3,8],[5,8],[5,0]]
	,[[0,1,2,3]]
	]]
  ,[125,"}","}",  "", "",[[0,0],[8,8]],[
	[[2,1],[2,2],[3,2],[3,4],[4,4],[4,5],[3,5],[3,7],[2,7],[2,8],[4,8],[4,7],[5,7],[5,5],[6,5],[6,4],[5,4],[5,2],[4,2],[4,1]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[126,"~","~",  "", "",[[0,0],[8,8]],[
	[[2,5],[2,6]
		,[3-dx,6],[3,6+dy]
	,[3,7],[5,7],[5,6]
		,[6-dx,6],[6,6+dy]
	,[6,7],[7,7],[7,6]
		,[6+dx,6],[6,6-dy]
	,[6,5],[4,5],[4,6]
		,[3+dx,6],[3,6-dy]
	,[3,5]]
	,[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
	]]
  ,[127,"^?","",  "DEL","Delete",[[0,0],[8,8]],[]]
  ] ];

// From http://www.brailleauthority.org/sizespacingofbraille/
//
//   Section 3.2 of Specification 800 (Braille Books and Pamphlets) February 2008 reads as follows:
//     Size and Spacing
//     3.2.1	The nominal height of braille dots shall be 0.019 inches [0.48 mm] and shall be uniform within any given transcription.
//     3.2.2	The nominal base diameter of braille dots shall be 0.057 inches [1.44 mm].
//     3.2.3	Cell spacing of dots shall conform to the following:
//     3.2.3.1	The nominal distance from center to center of adjacent dots (horizontally or vertically, but not diagonally)
//              in the same cell shall be 0.092 inches [2.340 mm].
//     3.2.3.2	The nominal distance from center to center of corresponding dots in adjacent cells shall be 0.245 inches [6.2 mm].
//     3.2.4    The nominal line spacing of braille cells from center to center of nearest corresponding dots in adjacent lines shall
//              be 0.400 inches [1.000 cm].
//
// Additional References:
//    http://www.loc.gov/nls/specs/800.pdf
//    http://www.tiresias.org/research/reports/braille_cell.htm
module braille_ascii_spec800(inString,dot_backing=true,cell_backing=false,justify=1,align=-1,dot_h=0.48,dot_d=1.44,dot_spacing=2.340,cell_d2d_spacing=6.2, line_d2d_spacing=10.0, echo_translate=true) {
  // justify:
  //  -1 : left side
  //   0 : center
  //   1 : right side (default)
  // align:
  //  -1 : bottom braille cell edge - shift up (default)
  //   0 : center braille cell
  //   1 : top braille cell edge - shift down
  thisFont=braille_ascii_font(dot_h=dot_h,dot_d=dot_d,dot_spacing=dot_spacing
	,cell_d2d_spacing=cell_d2d_spacing,line_d2d_spacing=line_d2d_spacing);
  x_shift=thisFont[0][0];
  y_shift=thisFont[0][1];
  theseIndicies=search(inString,thisFont[2],1,1);
  for( i=[0:len(theseIndicies)-1]) translate([i*x_shift-(1-justify)*x_shift*len(theseIndicies)/2,-y_shift*(align+1)/2]) {
	dotPattern=thisFont[2][theseIndicies[i]][6];
    if(dot_backing) translate([cell_d2d_spacing/2-dot_spacing/2-dot_d/2,line_d2d_spacing/2-dot_spacing-dot_d/2,-dot_h]) 
	cube(size=[dot_spacing+dot_d,2*dot_spacing+dot_d,dot_h],center=false);
    if(cell_backing) translate([0,0,-dot_h]) 
	cube(size=[x_shift,y_shift,dot_h],center=false);
    if(echo_translate) echo(str(inString[i]," maps to '",thisFont[2][theseIndicies[i]][4],"'"));
    for(dotIndex=dotPattern) {
      translate([cell_d2d_spacing/2-dot_spacing/2+floor((dotIndex-1)/3)*dot_spacing
		, line_d2d_spacing/2-dot_spacing+(2-(dotIndex-1)%3)*dot_spacing])
        scale([dot_d,dot_d,2*dot_h]) sphere($fn=8,r=0.5);
    }
  }
}

// Encoding from http://en.wikipedia.org/wiki/Braille_ASCII
// Dot Pattern:
//  1 4
//  2 5
//  3 6
function braille_ascii_font(dot_h=0.48,dot_d=1.44,dot_spacing=2.340,cell_d2d_spacing=6.2,line_d2d_spacing=10.0) = [
  [cell_d2d_spacing,line_d2d_spacing,0,"bump"],["Decimal Byte","Caret Notation","Character Escape Code","Abbreviation","Name","Bound Box","[bump_list]"]
  ,[
   [  0,"^@","\0","NUL","Null character",[[0,0],[2,3]],[]]
  ,[  1,"^A","",  "SOH","Start of Header",[[0,0],[2,3]],[]]
  ,[  2,"^B","",  "STX","Start of Text",[[0,0],[2,3]],[]]
  ,[  3,"^C","",  "ETX","End of Text",[[0,0],[2,3]],[]]
  ,[  4,"^D","",  "EOT","End of Transmission",[[0,0],[2,3]],[]]
  ,[  5,"^E","",  "ENQ","Enquiry",[[0,0],[2,3]],[]]
  ,[  6,"^F","",  "ACK","Acknowledgment",[[0,0],[2,3]],[]]
  ,[  7,"^G","\a","BEL","Bell",[[0,0],[2,3]],[]]
  ,[  8,"^H","\b","BS", "Backspace",[[0,0],[2,3]],[]]
  ,[  9,"^I","\t","HT", "Horizontal Tab",[[0,0],[2,3]],[]]
  ,[ 10,"^J","\n","LF", "Line Feed",[[0,0],[2,3]],[]]
  ,[ 11,"^K","\v","VT", "Vertical Tab",[[0,0],[2,3]],[]]
  ,[ 12,"^L","\f","FF", "Form feed",[[0,0],[2,3]],[]]
  ,[ 13,"^M","\r","CR", "Carriage return",[[0,0],[2,3]],[]]
  ,[ 14,"^N","",  "SO", "Shift Out",[[0,0],[2,3]],[]]
  ,[ 15,"^O","",  "SI", "Shift In",[[0,0],[2,3]],[]]
  ,[ 16,"^P","",  "DLE","Data Link Escape",[[0,0],[2,3]],[]]
  ,[ 17,"^Q","",  "DC1","Device Control 1",[[0,0],[2,3]],[]]
  ,[ 18,"^R","",  "DC2","Device Control 2",[[0,0],[2,3]],[]]
  ,[ 19,"^S","",  "DC3","Device Control 3",[[0,0],[2,3]],[]]
  ,[ 20,"^T","",  "DC4","Device Control 4",[[0,0],[2,3]],[]]
  ,[ 21,"^U","",  "NAK","Negative Acknowledgement",[[0,0],[2,3]],[]]
  ,[ 22,"^V","",  "SYN","Synchronous Idle",[[0,0],[2,3]],[]]
  ,[ 23,"^W","",  "ETB","End of Transmission Block",[[0,0],[2,3]],[]]
  ,[ 24,"^X","",  "CAN","Cancel",[[0,0],[2,3]],[]]
  ,[ 25,"^Y","",  "EM", "End of Medium",[[0,0],[2,3]],[]]
  ,[ 26,"^Z","",  "SUB","Substitute",[[0,0],[2,3]],[]]
  ,[ 27,"^[","\e","ESC","Escape",[[0,0],[2,3]],[]]
  ,[ 28,"^\\","", "FS", "File Separator",[[0,0],[2,3]],[]]
  ,[ 29,"^]","",  "GS", "Group Separator",[[0,0],[2,3]],[]]
  ,[ 30,"^^","",  "RS", "Record Separator",[[0,0],[2,3]],[]]
  ,[ 31,"^_","",  "US", "Unit Separator",[[0,0],[2,3]],[]]
  ,[ 32," "," ",  "", "Space",[[0,0],[2,3]],[]]
  ,[ 33,"!","!",  "", "the",[[0,0],[2,3]],[ 2,3,4,6 ]]
  ,[ 34,"\"","\"","", "(contraction)",[[0,0],[2,3]],[ 5 ]]
  ,[ 35,"#","#",  "", "(number prefix)",[[0,0],[2,3]],[ 3,4,5,6 ]]
  ,[ 36,"$","$",  "", "ed",[[0,0],[2,3]],[ 1,2,4,6 ]]
  ,[ 37,"%","%",  "", "sh",[[0,0],[2,3]],[ 1,4,6 ]]
  ,[ 38,"&","&",  "", "and",[[0,0],[2,3]],[ 1,2,3,4,6 ]]
  ,[ 39,"'","'",  "", "",[[0,0],[2,3]],[ 3 ]]
  ,[ 40,"(","(",  "", "of",[[0,0],[2,3]],[ 1,2,3,5,6 ]]
  ,[ 41,")",")",  "", "with",[[0,0],[2,3]],[ 2,3,4,5,6 ]]
  ,[ 42,"*","*",  "", "ch",[[0,0],[2,3]],[ 1,6 ]]
  ,[ 43,"+","+",  "", "ing",[[0,0],[2,3]],[ 3,4,6 ]]
  ,[ 44,",",",",  "", "(uppercase prefix)",[[0,0],[2,3]],[ 6 ]]
  ,[ 45,"-","-",  "", "",[[0,0],[2,3]],[ 3,6 ]]
  ,[ 46,".",".",  "", "(italic prefix)",[[0,0],[2,3]],[ 4,6 ]]
  ,[ 47,"/","/",  "", "st",[[0,0],[2,3]],[ 3,4 ]]
  ,[ 48,"0","0",  "", "\"",[[0,0],[2,3]],[ 3,5,6 ]]
  ,[ 49,"1","1",  "", ",",[[0,0],[2,3]],[ 2 ]]
  ,[ 50,"2","2",  "", ";",[[0,0],[2,3]],[ 2,3 ]]
  ,[ 51,"3","3",  "", ":",[[0,0],[2,3]],[ 2,5 ]]
  ,[ 52,"4","4",  "", ".",[[0,0],[2,3]],[ 2,5,6 ]]
  ,[ 53,"5","5",  "", "en",[[0,0],[2,3]],[ 2,6 ]]
  ,[ 54,"6","6",  "", "!",[[0,0],[2,3]],[ 2,3,5 ]]
  ,[ 55,"7","7",  "", "( or )",[[0,0],[2,3]],[ 2,3,5,6 ]]
  ,[ 56,"8","8",  "", "\" or ?",[[0,0],[2,3]],[ 2,3,6 ]]
  ,[ 57,"9","9",  "", "in",[[0,0],[2,3]],[ 3,5 ]]
  ,[ 58,":",":",  "", "wh",[[0,0],[2,3]],[ 1,5,6 ]]
  ,[ 59,";",";",  "", "(letter prefix)",[[0,0],[2,3]],[ 5,6 ]]
  ,[ 60,"<","<",  "", "gh",[[0,0],[2,3]],[ 1,2,6 ]]
  ,[ 61,"=","=",  "", "for",[[0,0],[2,3]],[ 1,2,3,4,5,6 ]]
  ,[ 62,">",">",  "", "ar",[[0,0],[2,3]],[ 3,4,5 ]]
  ,[ 63,"?","?",  "", "th",[[0,0],[2,3]],[ 1,4,5,6 ]]
  ,[ 64,"@","@",  "", "(accent prefix)",[[0,0],[2,3]],[ 4 ]]
  ,[ 65,"A","A",  "", "a",[[0,0],[2,3]],[ 1 ]]
  ,[ 66,"B","B",  "", "b",[[0,0],[2,3]],[ 1,2 ]]
  ,[ 67,"C","C",  "", "c",[[0,0],[2,3]],[ 1,4 ]]
  ,[ 68,"D","D",  "", "d",[[0,0],[2,3]],[ 1,4,5 ]]
  ,[ 69,"E","E",  "", "e",[[0,0],[2,3]],[ 1,5 ]]
  ,[ 70,"F","F",  "", "f",[[0,0],[2,3]],[ 1,2,4 ]]
  ,[ 71,"G","G",  "", "g",[[0,0],[2,3]],[ 1,2,4,5 ]]
  ,[ 72,"H","H",  "", "h",[[0,0],[2,3]],[ 1,2,5 ]]
  ,[ 73,"I","I",  "", "i",[[0,0],[2,3]],[ 2,4 ]]
  ,[ 74,"J","J",  "", "j",[[0,0],[2,3]],[ 2,4,5 ]]
  ,[ 75,"K","K",  "", "k",[[0,0],[2,3]],[ 1,3 ]]
  ,[ 76,"L","L",  "", "l",[[0,0],[2,3]],[ 1,2,3 ]]
  ,[ 77,"M","M",  "", "m",[[0,0],[2,3]],[ 1,3,4 ]]
  ,[ 78,"N","N",  "", "n",[[0,0],[2,3]],[ 1,3,4,5 ]]
  ,[ 79,"O","O",  "", "o",[[0,0],[2,3]],[ 1,3,5 ]]
  ,[ 80,"P","P",  "", "p",[[0,0],[2,3]],[ 1,2,3,4 ]]
  ,[ 81,"Q","Q",  "", "q",[[0,0],[2,3]],[ 1,2,3,4,5 ]]
  ,[ 82,"R","R",  "", "r",[[0,0],[2,3]],[ 1,2,3,5 ]]
  ,[ 83,"S","S",  "", "s",[[0,0],[2,3]],[ 2,3,4 ]]
  ,[ 84,"T","T",  "", "t",[[0,0],[2,3]],[ 2,3,4,5 ]]
  ,[ 85,"U","U",  "", "u",[[0,0],[2,3]],[ 1,3,6 ]]
  ,[ 86,"V","V",  "", "v",[[0,0],[2,3]],[ 1,2,3,6 ]]
  ,[ 87,"W","W",  "", "w",[[0,0],[2,3]],[ 2,4,5,6 ]]
  ,[ 88,"X","X",  "", "x",[[0,0],[2,3]],[ 1,3,4,6 ]]
  ,[ 89,"Y","Y",  "", "y",[[0,0],[2,3]],[ 1,3,4,5,6 ]]
  ,[ 90,"Z","Z",  "", "z",[[0,0],[2,3]],[ 1,3,5,6 ]]
  ,[ 91,"[","[",  "", "ow",[[0,0],[2,3]],[ 2,4,6 ]] // ]]
  ,[ 92,"\\","\\","", "ou",[[0,0],[2,3]],[ 1,2,5,6 ]]  // [[
  ,[ 93,"]","]",  "", "er",[[0,0],[2,3]],[ 1,2,4,5,6 ]] 
  ,[ 94,"^","^",  "", "(contraction)",[[0,0],[2,3]],[ 4,5 ]]
  ,[ 95,"_","_",  "", "(contraction)",[[0,0],[2,3]],[ 4,5,6 ]]
  ,[ 96,"`","`",  "", "",[[0,0],[2,3]],[
	]]
// Repeating upper-case patterns for lower-case letters.
  ,[ 97,"a","a",  "", "a",[[0,0],[2,3]],[ 1 ]]
  ,[ 98,"b","b",  "", "b",[[0,0],[2,3]],[ 1,2 ]]
  ,[ 99,"c","c",  "", "c",[[0,0],[2,3]],[ 1,4 ]]
  ,[100,"d","d",  "", "d",[[0,0],[2,3]],[ 1,4,5 ]]
  ,[101,"e","e",  "", "e",[[0,0],[2,3]],[ 1,5 ]]
  ,[102,"f","f",  "", "f",[[0,0],[2,3]],[ 1,2,4 ]]
  ,[103,"g","g",  "", "g",[[0,0],[2,3]],[ 1,2,4,5 ]]
  ,[104,"h","h",  "", "h",[[0,0],[2,3]],[ 1,2,5 ]]
  ,[105,"i","i",  "", "i",[[0,0],[2,3]],[ 2,4 ]]
  ,[106,"j","j",  "", "j",[[0,0],[2,3]],[ 2,4,5 ]]
  ,[107,"k","k",  "", "k",[[0,0],[2,3]],[ 1,3 ]]
  ,[108,"l","l",  "", "l",[[0,0],[2,3]],[ 1,2,3 ]]
  ,[109,"m","m",  "", "m",[[0,0],[2,3]],[ 1,3,4 ]]
  ,[110,"n","n",  "", "n",[[0,0],[2,3]],[ 1,3,4,5 ]]
  ,[111,"o","o",  "", "o",[[0,0],[2,3]],[ 1,3,5 ]]
  ,[112,"p","p",  "", "p",[[0,0],[2,3]],[ 1,2,3,4 ]]
  ,[113,"q","q",  "", "q",[[0,0],[2,3]],[ 1,2,3,4,5 ]]
  ,[114,"r","r",  "", "r",[[0,0],[2,3]],[ 1,2,3,5 ]]
  ,[115,"s","s",  "", "s",[[0,0],[2,3]],[ 2,3,4 ]]
  ,[116,"t","t",  "", "t",[[0,0],[2,3]],[ 2,3,4,5 ]]
  ,[117,"u","u",  "", "u",[[0,0],[2,3]],[ 1,3,6 ]]
  ,[118,"v","v",  "", "v",[[0,0],[2,3]],[ 1,2,3,6 ]]
  ,[119,"w","w",  "", "w",[[0,0],[2,3]],[ 2,4,5,6 ]]
  ,[120,"x","x",  "", "x",[[0,0],[2,3]],[ 1,3,4,6 ]]
  ,[121,"y","y",  "", "y",[[0,0],[2,3]],[ 1,3,4,5,6 ]]
  ,[122,"z","z",  "", "z",[[0,0],[2,3]],[ 1,3,5,6 ]]
  ,[123,"{","{",  "", "",[[0,0],[2,3]],[
	]]
  ,[124,"|","|",  "", "",[[0,0],[2,3]],[
	]]
  ,[125,"}","}",  "", "",[[0,0],[2,3]],[
	]]
  ,[126,"~","~",  "", "",[[0,0],[2,3]],[
	]]
  ,[127,"^?","",  "DEL","Delete",[[0,0],[2,3]],[]]
  ] ];
gitdir: ../../.git/modules/libraries/MCAD
include <../bitmap/name_tag.scad>;

translate([0,0,0])
name_tag("name_tag");

translate([20,0,0]) // 0 + 16/2 + 16/2 + 4
name_tag("NAME_TAG");

translate([52,0,0]) // 20 + 16/2 + 40/2 + 4
name_tag("name_tag", block_size=5);

translate([96,0,0]) // 52 + 40/2 + 40/2 + 4
name_tag("NAME_TAG", block_size=5);

translate([130,0,0]) // 92 + 40/2 + 16/2 + 4
name_tag("name_tag", height=30);

translate([150,0,0]) // 130 + 16/2 + 16/2 + 4
name_tag("NAME_TAG", height=30);
/*
Parametric Alphabet Block 
Tony Buser <tbuser@gmail.com>
http://tonybuser.com
http://creativecommons.org/licenses/by/3.0/
*/

use <bitmap.scad>

// change to any letter
letter = "A";

union() {
	difference() {
		cube(size = 20);
		translate(v = [2, 2, 17]) {
			cube(size = [16, 16, 5]);
		}
	}

	translate(v = [10, 10, 15]) {
		8bit_char(letter, 2, 5);
	}
}
/*
Parametric letters for for a necklace
Elmo Mäntynen <elmo.mantynen@iki.fi>
LGPL 2.1
*/

use <bitmap.scad>

// change chars array and char_count
// OpenSCAD has no string or length methods :(
chars = ["M","a","k","e","r","B","o","t"];
char_count = 8;

// block size 1 will result in 8mm per letter
block_size = 2;
// height is the Z height of each letter
height = 3;

//Hole for the necklace
hole_diameter = 5;

module 8bit_str(chars, char_count, block_size, height) {
	echo(str("Total Width: ", block_size * 8 * char_count, "mm"));
	union() {
		for (count = [0:char_count-1]) {
			translate(v = [0, count * block_size * 8, 0]) {
				8bit_char(chars[count], block_size, height);
			}
		}
	}
}

module letter(char, block_size, height, hole_diameter) {
	union() {
		translate(v = [0,0, hole_diameter*1.3]) {
			8bit_char(char, block_size, height);
		}
		translate(v = [0,0,(hole_diameter*1.3)/2]) {
			color([0,0,1,1]) {
				difference() {
					cube(size = [block_size * 8, block_size * 8, hole_diameter+2], center = true);
					rotate([90, 0, 0]) cylinder(h = block_size * 8 + 1, r = hole_diameter/2, center = true);
				}
			}
		}
	}
}

matrix = [["O",  "L", "E", "N", "S"], 
		[ "Y", "OE", "N", "Y", "T"]];

union() {
	for (column = [0:1]) {
		for (row = [0:4]) {
			translate(v=[column*(block_size*1.1)*8, row*(block_size*1.1)*8, 0])
				letter(matrix[column][row], block_size, height, hole_diameter);
		}
	}	
}
/*
Height Map Example
Tony Buser <tbuser@gmail.com>
http://tonybuser.com
http://creativecommons.org/licenses/by/3.0/

Can also dynamically run this by passing an array on the command line:

/Applications/OpenSCAD.app/Contents/MacOS/OpenSCAD -m make -D bitmap=[2,2,2,0,1,3,2,2,2] -D row_size=3 -s height_map.stl height_map.scad
*/

use <bitmap.scad>

block_size = 5;
height = 5;

row_size = 10; // 10x10 pixels
bitmap = [
	1,1,0,0,1,1,0,0,1,1,
	1,1,1,1,1,1,1,1,1,1,
	0,1,2,2,1,1,2,2,1,0,
	0,1,2,1,1,1,1,2,1,0,
	1,1,1,1,3,3,1,1,1,1,
	1,1,1,1,3,3,1,1,1,1,
	0,1,2,1,1,1,1,2,1,0,
	0,1,2,2,1,1,2,2,1,0,
	1,1,1,1,1,1,1,1,1,1,
	1,1,0,0,1,1,0,0,1,1
];

bitmap(bitmap, block_size, height, row_size);
/*
Bitmap and 8Bit Font Module
Tony Buser <tbuser@gmail.com>
http://tonybuser.com
http://creativecommons.org/licenses/by/3.0/
*/

module bitmap(bitmap, block_size, height, row_size) {
	width = block_size * row_size;
	bitmap_size = row_size * row_size;
	
	function loc_x(loc) = floor(loc / row_size) * block_size;
	function loc_y(loc) = loc % row_size * block_size;
	function loc_z(loc) = (bitmap[loc]*height-height)/2;

	translate(v = [-width/2+block_size/2,-width/2+block_size/2,height/2]) {
		for (loc = [0:bitmap_size - 1]) {
			if (bitmap[loc] != 0) {
				union() {
					translate(v = [loc_x(loc), loc_y(loc), loc_z(loc)]) {
						cube(size = [block_size, block_size, height * bitmap[loc]], center = true);
					}
				}
			}
		}
	}
}

module 8bit_char(char, block_size, height, include_base) {
	if (char == "0") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,1,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "1") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "2") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "3") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "4") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,1,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "5") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "6") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "7") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "8") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "9") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "A") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "B") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "C") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "D") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,0,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,1,1,0,0,
			0,1,1,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "E") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "F") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "G") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "H") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "I") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "J") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,1,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "K") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,1,1,0,0,
			0,1,1,1,1,0,0,0,
			0,1,1,1,1,0,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "L") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "M") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,1,1,
			0,1,1,1,0,1,1,1,
			0,1,1,1,1,1,1,1,
			0,1,1,0,1,0,1,1,
			0,1,1,0,0,0,1,1,
			0,1,1,0,0,0,1,1,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "N") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,0,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "O") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "P") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "Q") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,0,1,1,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "R") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "S") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "T") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "U") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "V") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "W") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,1,1,
			0,1,1,0,0,0,1,1,
			0,1,1,0,1,0,1,1,
			0,1,1,1,1,1,1,1,
			0,1,1,1,0,1,1,1,
			0,1,1,0,0,0,1,1,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "X") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "Y") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "Z") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "OE") {
		bitmap([
			0,0,1,0,0,1,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0
		], block_size, height, 8);
	} else if (char == "a") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "b") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "c") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "d") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "e") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "f") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "g") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,1,1,0,
			0,1,1,1,1,1,0,0
		], block_size, height, 8);
	} else if (char == "h") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "i") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "j") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,1,1,1,1,0,0
		], block_size, height, 8);
	} else if (char == "k") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,1,1,0,0,0,
			0,1,1,0,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "l") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "m") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,1,1,
			0,1,1,1,1,1,1,1,
			0,1,1,0,1,0,1,1,
			0,1,1,0,0,0,1,1,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "n") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "o") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "p") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "q") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,1,1,0
		], block_size, height, 8);
	} else if (char == "r") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "s") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "t") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "u") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "v") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "w") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,1,1,
			0,1,1,0,1,0,1,1,
			0,1,1,1,1,1,1,1,
			0,0,1,1,1,1,1,0,
			0,0,1,1,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "x") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else if (char == "y") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,1,1,0,0,
			0,1,1,1,1,0,0,0
		], block_size, height, 8);
	} else if (char == "z") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "+") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,1,1,1,1,1,1,0,
			0,1,1,1,1,1,1,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "-") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == ":") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == ".") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == ",") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "?") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "=") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,1,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "*") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,0,1,1,1,1,0,0,
			1,1,1,1,1,1,1,1,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "!") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "''") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "#") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			1,1,1,1,1,1,1,1,
			0,1,1,0,0,1,1,0,
			0,1,1,0,0,1,1,0,
			1,1,1,1,1,1,1,1,
			0,1,1,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "$") {
		bitmap([
			0,0,0,1,1,0,0,0,
			0,0,1,1,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,1,1,1,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "%") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,1,1,0,0,
			0,0,1,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,0,0,1,1,0,
			0,1,0,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "&") {
		bitmap([
			0,0,0,1,1,1,0,0,
			0,0,1,1,0,1,1,0,
			0,0,0,1,1,1,0,0,
			0,0,1,1,1,0,0,0,
			0,1,1,0,1,1,1,1,
			0,1,1,0,1,1,1,0,
			0,0,1,1,1,0,1,1,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "@") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,1,1,0,0,1,1,0,
			0,1,1,0,1,1,1,0,
			0,1,1,0,1,1,1,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,1,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "'") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "(") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,1,1,1,0,0,
			0,0,1,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == ")") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,1,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,1,0,0,
			0,0,1,1,1,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "<") {
		bitmap([
			0,0,0,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == ">") {
		bitmap([
			0,1,1,0,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "[") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "]") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,1,1,0,0,
			0,0,1,1,1,1,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "/") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,1,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "\\") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,1,1,0,0,0,0,0,
			0,0,1,1,0,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,0,1,1,0,0,
			0,0,0,0,0,1,1,0,
			0,0,0,0,0,0,1,0,
			0,0,0,0,0,0,0,0
		], block_size, height, 8);
	} else 	if (char == "_") {
		bitmap([
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1
		], block_size, height, 8);
	} else 	if (char == "|") {
		bitmap([
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0,
			0,0,0,1,1,0,0,0
		], block_size, height, 8);
	} else {
		echo("Invalid Character: ", char);
	}

}

module 8bit_str(chars, char_count, block_size, height) {
	echo(str("Total Width: ", block_size * 8 * char_count, "mm"));
	union() {
		for (count = [0:char_count-1]) {
			translate(v = [0, count * block_size * 8, 0]) {
				8bit_char(chars[count], block_size, height);
			}
		}
	}
}

/*
<bitmap.scad>

block_size = 5;
height = 10;

union() {
	translate(v = [0,0,5]) {
		8bit_char("A", block_size, height);

		//bitmap([
		//	1,1,1,1,1,1,1,1,
		//	1,0,0,1,1,0,0,1,
		//	1,0,1,1,1,1,0,1,
		//	1,1,1,0,0,1,1,1,
		//	1,1,1,0,0,1,1,1,
		//	1,0,1,1,1,1,0,1,
		//	1,0,0,1,1,0,0,1,
		//	1,1,1,1,1,1,1,1
		//], block_size, height, 8);

		//bitmap([
		//	1,1,1,1, 
		//	1,0,0,1, 
		//	1,0,0,1, 
		//	1,1,1,1 
		//], block_size, height, 4);
	}
	translate(v = [0,0,5/2]) {
		color([0,0,1,1]) {
			cube(size = [block_size * 8, block_size * 8, 5], center = true);
		}
	}
}

<bitmap.scad>

chars = ["T","O","N","Y","","B","U","S","E","R"];
char_count = 10;
block_size = 1;
height = 5;

union() {
	translate(v = [0,-block_size*8*char_count/2+block_size*8/2,5]) {
		8bit_str(chars, char_count, block_size, height);
	}
	translate(v = [0,0,5/2]) {
		color([0,0,1,1]) {
			cube(size = [block_size * 8, block_size * 8 * char_count, 5], center = true);
		}
	}
}
*/
/*
Parametric Name Tag 
Tony Buser <tbuser@gmail.com>
http://tonybuser.com
http://creativecommons.org/licenses/by/3.0/
*/

use <bitmap.scad>

/*
 chars = chars array
 block_size = letter size (block size 1 will result in 8mm per letter)
 height = the Z height of each letter in mm
 key_ring_hole = (boolean) Append a hole to a keyring, necklace etc. ?
*/
module name_tag(chars = ["R", "E", "P", "R", "A", "P"],
    block_size = 2, height = 3, key_ring_hole = true) {
  char_count = len(chars);
  union() {
    translate(v = [0,-block_size*8*char_count/2+block_size*8/2,3]) {
      8bit_str(chars, char_count, block_size, height);
    }
    translate(v = [0,0,3/2]) {
      color([0,0,1,1]) {
        cube(size = [block_size * 8, block_size * 8 * char_count, 3], center = true);
      }
    }
    if (key_ring_hole == true){
      translate([0, block_size * 8 * (char_count+1)/2, 3/2])	
      difference(){
        cube(size = [block_size * 8, block_size * 8 , 3], center = true);
        cube(size = [block_size * 4, block_size * 4 , 5], center = true);
      }
    }
  }
}
This is an OpenSCAD module that let's you easily (well kinda) create 3D text. I've emulated the Atari 8-Bit fonts A-Z, a-z, 0-9, and most punctuation. You can create them a letter at a time or pass an array of characters. (OpenSCAD doesn't have any real string manipulation)

It also has a bitmap module that you can use to define your own fonts. It's pretty simple, you pass it an array of numbers, then tell it how many bits per row and it creates cubes (of configurable width and height) in a grid and combines them into a single shape.  The number in the array sets the pixel height modifier.  So if you set height to 5 and the array value is 2, then the height of that pixel will be 10mm.

Be careful when defining your own bitmaps in that you can't have two bits only connected diagonally. Otherwise OpenSCAD will say it's not manifold. For instance you can't have:

0 0 0
0 1 0
0 0 1

But you can have:

0 0 0
0 1 1
0 0 1

For more info see: http://www.thingiverse.com/thing:2054
